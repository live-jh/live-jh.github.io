[{"content":"다사다난 했던 2020년도 어느덧 12월 중순에 접어들었다. 개발자로 일한지는 약 1년 6개월정도 된 것 같다. 얼마 안된 나의 경험을 통해 부족하지만 스타트업에서 신입 개발자가 효율적으로 일하는 방법에 대해 간략히 요약해보려고 한다.\n나는 참고로 나는 비전공 고졸 개발자다.\n좋지 않은 배경에서 시작했기에 나는 개발 관련 아티클을 출퇴근길에 읽기 시작했다. 단어의 의미도 모르고 읽다보니 처음엔 이해가 안되었지만 지속적으로 비슷한 내용들이 눈에 들어오기 시작했고 그 중엔 일하는 방법에 대한 내용도 있었다. 그 당시엔 내용을 읽으면서 진짜일까 싶었는데 역시 경험한 자의 조언은 남다르다는 사실을 깨닫는데 그리 오랜 시간이 걸리지 않았다.\n짧지만 내가 느낀 요소는 다음과 같다.\n질문은 똑똑하게 답변은 명확하게 지금은 어떨지 모르겠지만 나의 학창시절은 질문하면 안되는(?) 이상한(?) 그런 분위기를 가지고 있었다.\n모르면 선생님에게 물어보는게 맞는데 오히려 쉬는 시간 공부잘하는 친구에게 가서 물어보곤 했던 기억이 난다. 이러한 환경에 자라서 그런지 업무시 질문하는 것이 굉장히 낯설었다.\n신입개발자는 모르는게 투성이다. 글을 쓰고 있는 나 역시도 모르는게 많고 채워야 할 부분이 많다.\n궁금한게 있으면 질문을 해야하는데 그게 너무 어려웠다. 나중엔 처음이 가장 힘들다고 끙끙 앓다가 겨우 질문을 하니 너무 손쉽게 해결되는 것에 허탈했다.\n\u0026ldquo;몇시간동안 붙잡고 고민했는데 겨우 이거 하나였다고?\u0026rdquo; 란 사실에 망연자실하면서 한편으로 후련했던 기억이 난다.\n내 경험상 질문의 퀄리티에 따라 또는 문제 상황에 따라 질문의 답이 본인에게 득이 될지 기준은 스스로가 정한다고 생각한다. 손쉽게 문제 상황을 해결하는 것보다 충분히 혼자 고민하고 여러 시도를 해보며 겪는 시행착오가 쌓인 뒤 질문에 대한 해답을 들었을때 습득 효과는 경험상 더 기억에 많이 남았던 것 같다. 또한 고민을 하는 동안엔 내가 정확히 무엇을 모르는지 알아가는 시간을 보내게 되고 질문을 할 때 조금 더 명확한 답변을 들을 수 있게 똑똑한 질문을 할 수 있게 된다.\n이는 질문하는 하는 사람과 답변을 주는 사람 모두에게 효율적인 커뮤니케이션을 할 수 있도록 도와준다.\n소통의 중요성 프로젝트 관리에 있어 소통은 매우 중요하다고 생각한다. 보통 사수 또는 경력이 많은 사람들은 신입 또는 주니어들의 업무 역량이 어느정도인지 알고 있다. 이를 통해 메인역할을 하면서 서브 작업을 나눠주는 방식으로 일한다.\n내 경험을 간략히 이야기하자면 나는 사실 개발자 일을 처음 시작했을 당시 조금 답답하게 일하는 타입이었다. 무조건 내가 받은건 내가 끝내야 하는 것인줄 알았고 한 시간만 더 생각하고 붙잡아보자가 3시간이 되고 3시간이 결국 하루가 되버리는 경우가 종종 발생했다.\n지금 생각해보면 그때 당시 내 능력 부족이라 느껴 피해를 끼치지 말아야지라고 꽉 막힌 책임감으로 그랬던 것 같다. 하지만 지금와서 돌이켜보면 어느정도 고민을 충분히 해보고나서도 풀리지 않을때는 당시 상황을 팀원에게 공유하고 함께 해결해나가거나 도움을 받는게 맞다고 생각한다.\n개인이 아닌 다수가 함께 일을 하고 있기 때문에 내 일이 곧 내 동료의 일이 된다. 내가 작성한 코드는 나의 팀원이 사용하게 될 것이고 사수가 작성한 코드는 또 다른 누군가 사용하게 된다. 효율적인 업무를 진행하고 협업의 의미를 조금 더 견고히 하는 것, 그게 바로 소통이라 생각한다.\n소통은 팀원과의 관계에서도 좋은 영향을 끼칠 수 있는 가장 쉬운 방법은 하나이다. 올바른 의사소통을 통해 나의 동료에게 긍정적 효과를 일으킨다면 더욱 즐겁게 개발하는 환경 도 자연스레 만들어지지 않을까?\n오늘 업무(할 일)를 정리하기 비유를 하자면 할 일을 정리하는 것은 마치 요리 레시피를 메모하는 것과 같다고 생각한다.\n나같은 사람은 요리할 때 생각을 하기보다는 단순히 눈에 보여지는 재료와 용량을 보며 따라서 조리한다. 많은 생각을 하다보면 재료를 넣어야 할 타이밍을 놓칠 수도 있고 메모를 하지 않으면 어떤 재료를 빼먹을 수도 있기 때문이다. 비유가 적절하지 않을 수도 있지만 할 일을 정리하는 것도 마찬가지라고 생각한다.\n쉽게 말해 생각과 행동을 분리해 집중하기 위해서다. 요즘은 많은 정보와 데이터들에 노출되어 정리를 하지 않으면 해야할 일이나 나중에 봐야지 했던 것들을 놓치는 경우가 빈번히 발생한다. (물론 나만 그럴수도 있는점..)\n그렇기 때문에 할 일에 대한 간략한 정보를 리스트업을 해놓고 하나씩 행동으로 옮기는 것이다. 대표적으로 칸반보드를 활용하는 것도 있지만 실제로 칸반보드를 사용하게 되면 너무 디테일해지는 경우도 종종 발생해서 정말 한줄 요약하듯 간단히 3~5개정도로 매일매일 daily로 typora 앱을 사용해 적어두고 하는 편이다.\n주관적이지만 나의 경우는 이 습관이 매우 잘 맞는다. 대신에 문서화처럼 너무 복잡하고 디테일해지지 않는 것이 포인트다.\n typora를 사용하여 날짜별로 할일을 간단히 정리하고 있다.\n처음엔 일별로 정리했는데 너무 관리가 안되서 이제는 월 기준 한 파일로 관리중이다.\n 같은 실수를 반복하지 않는다. 사람이기에 누구나 실수할 수 있다. 완벽할 수 없고 처음엔 잘 모르기 때문에 신입 개발자의 실수는 어찌보면 당연하고 자연스럽게 바라볼 수도 있다.\n하지만 늘 같은 실수를 반복하는 것은 문제가 있다고 생각한다. 물론 전에 했던 실수를 또 반복안한다는 보장은 없지만 적어도 이런 부분을 최소화하도록 개선의 노력이 필요하다는 것이다. 나는 이럴때마다 메모하는 습관을 들였고 몸에 익숙하게 스며들때까지 메모를 지우지 않고 잊을만 하면 찾아보는 루틴을 하고 있다.\n나는 모든 말과 행동엔 적절한 시기가 있다고 생각한다.\n신입 또는 주니어 시절에 경험할 수 있는 것들중에 하나가 경험에서 나오는 실수인데 이 부분이 매우 중요하다고 요새 많이 느낀다. 새로운 것을 경험을 해보지 않으면 실수조차 할 수 없고 나중에 경험하자니 리스크가 너무 크다. 매번 학습하고 새로운 것을 습득해야 하는 직무 특성상 피할 수 없으면 즐겨라 라는 문구처럼 지금 이 시기에 겪은 실수와 개선의 노력이 바탕이된 경험을 토대로 기반을 잘 다져놓으면 경력을 쌓고 난 이후 좋은 개발자로 성장해있지 않을까?\n 이러한 실수는 애교로 봐줄 수 있지 않을까?\n😄\n 마무리 전체적인 내용이 개발자만 해당하는 사실은 아닌 것 같다. 모든 사람들이 어떤 그룹에 속해 있던 한번쯤은 고민했을 기초적인 요소를 정리한 것 같다. 알면서도 쉽게 실천하지 못하는 부분도 있고 사람마다 처한 환경이나 스타일이 다르기 때문에 다른 견해를 가질수도 있다고 생각한다.\n보통 이런 글을 작성하기 전에 많은 글을 보게 되는데 개발 관련 자료를 보다보면 어리고 경력도 적은데 뛰어난 개발자들을 많이 보는 것 같다. 그때마다 매번 반성하고 나를 되돌아 보는 시간을 가지면서 나는 회사에서도 개인적으로도 잘하고 있는 걸까? 라는 물음을 던지곤 한다.\n물음에 대한 답은 늘 정해져 있다.\n초기의 노력은 너무 작아 주목할만한 차이를 가져오지 못하지만 점차적으로 쌓이게 되면 극적인 변화로 다가올 것이란 사실을 잊지 말아야 한다.\n 주 단위로 todo를 작성하고, 작업 대시보드를 사용하다보니\n양쪽으로 작성하기 너무 번거로워서 합쳐서 조금 수정해본 노션 대시보드\n내년부터는 정말 꼼꼼히 빠짐없이 작성할 수 있도록 노력해야겠다 :)\n 2020년은 코로나도 있었고고 야외에서 하는 특별한 결혼식을 준비하고 새로운 가정을 이루며 계획했던 일들을 많이 이루지 못했다. 하지만 아내와 함께 인생에 단 한번뿐인 특별한 경험을 했기에 전혀 후회는 없다. 모든 사람들이 사업, 취업, 입시, 노약자, 고연령층, 각종 경조사등등 각자의 위치에서 많은 것들을 내려놓을 수 밖에 없는 한해를 보낸 것 같아 너무 안타깝다.\n남은 12월은 그동안 내가 얼마나 성장했고 어떤 일들과 성과를 해왔는지 정리하고 반성하는 시간을 갖고자 한다. 내년쯤엔 올해보다 더 많이 성장해서 내가 꿈꾸는 개발자의 모습에 더 많이 다가갈 수 있었으면 좋겠다.\n","description":"","id":2,"section":"posts","tags":["신입개발자","비전공개발자","일잘하는법"],"title":"신입개발자가 효율적으로 일하는 방법","uri":"https://live-jh.github.io/posts/think/how-to-work-better/"},{"content":" 파이썬 + 장고를 통한 개발 환경 및 프로젝트 세팅이 필요할 때 매번 찾아보는 것에 불편함을 느껴 정리한 내용입니다.\n틀린 부분이 있다면 댓글로 알려주시면 감사하겠습니다 :)\n참고로 이 포스팅은 맥OS에 homebrew가 설치되어있는 가정하에 작성되었습니다.\n 목차   개발환경 세팅   프로젝트 생성   프로젝트 설정   앱 디자인 구성 및 settings key 관리   1. 개발환경 세팅 터미널을 실행시켜 다음의 명령어를 통해 파이썬이 어디에 설치되어 있는지 확인합니다.\n1 2 3  $ python3 -V Python 3.7.6 $ which python3   만약 설치되어 있지 않다면 터미널에 brew install python 명령어를 입력하여 파이썬을 설치합니다.\n1 2 3 4  $ python3 -V Python 3.7.6 $ which python3 /usr/bin/python3   pyenv로 파이썬의 버전을 유동적으로 변경시켜 사용할 수도 있습니다.\n먼저 pyenv를 설치하고 스크립트를 아래와 같이 추가시켜줍니다.\n1 2 3 4 5 6 7  # pyenv 설치 $ brew install pyenv # pyenv 활성화 스크립트 추가 $ echo -e \u0026#39;if command -v pyenv 1\u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then\\neval \u0026#34;$(pyenv init -)\u0026#34;\\nfi\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile $ exec \u0026#34;$SHELL\u0026#34; # shell 재실행   이후 pyenv 커맨드 명령어를 통해 사용하고자 하는 파이썬 3 버전들을 설치해줍니다.\n1 2 3 4 5 6 7 8 9  $ pyenv install 3.7.6 $ pyenv install 3.8.1 # 버전 활성화 변경 $ pyenv global 3.7.6 $ python -V Python 3.7.6 #pyenv versions   \n2. 프로젝트 생성  pycharm에서 new project 프로젝트명으로 새 폴더 생성 후 프로젝트 관리  Django 선택 후 location 에서 해당 프로젝트의 디렉토리 설정하기   가상환경 설정  new evironment using -\u0026gt; Virtualenv location은 해당 프로젝트 폴더내에 myvenv or venv 새 폴더 추가   인터프리터 설정 후 create  Result 3. 프로젝트 설정 프로젝트를 생성하면 새 프로젝트명의 앱이 하나 추가되어 있으며 그 하위에 wsgi, urls, settings, init등 다양한 파일들이 존재합니다.\n기본적인 프로젝트 구성은 튜토리얼용으로 적합하나 실제 프로젝트에 적용하기엔 그닥 유용하지 않기에 이를 조금 더 효율적으로 관리하기 위해서\n다음과 같이 프로젝트를 구성합니다.\nexample_1 example_2 (back-end \u0026amp; front-end) example_3 settings 설정  base : 프로젝트의 모든 인스턴스에 적용될 세팅 local : 로컬 환경에서 작업시 사용되는 세팅 (debug mode, log level, 개발전용) staging : 운영 환경 서버에 private version 을 가지고 구동되는 스테이징 서버 세팅 test : test runner, in memory, db info, log setting등 세팅 production : 실 운영 서버 세팅  runserver 관리 명령어\n shell start  python manage.py shell --settings=config.settings.production   local runserver  python manage.py runserver --settings=config.settings.local    4. 앱 디자인 구성 및 settings key 관리  ing..\n Reference    ","description":"","id":3,"section":"posts","tags":[""],"title":"[mac] 장고 프로젝트 설정 가이드","uri":"https://live-jh.github.io/posts/dev/django_project_setting/"},{"content":" 리액트 학습에 대한 정리하는 포스팅입니다.\n What is React? 리액트는 페이스북에서 제작한 자바스크립트 라이브러리입니다. 사용자 인터페이스를 구축하기 위해 사용되며 SPA 애플리케이션을 제작할 때 유용합니다. 리액트는 props 속성을 이용한 단방향 데이터 바인딩, 상태 관리, JSX(자바스크립트 문법으로 컴포넌트 렌더링), 가상 DOM, 컴포넌트 기반으로 동작하는등의 특징들을 가지고 있습니다.\nComponent 리액트 컴포넌트는 상태 값을 이용해 화면에 표현하며 쉽게 설명해 데이터를 입력받아 화면에 표시할 html을 반환하는 함수라 할 수 있습니다. 이때 사용하는 문법은 JSX를 사용합니다. JSX는 조건부 렌더링으로 if문을 사용할 수 없어 삼항연산자나 and연산자를 사용하는 특징을 가지고 있습니다. (리액트에서 JSX는 필수는 아닙니다.) 컴포넌트는 크게 클래스형 컴포넌트와 함수형 컴포넌트 로 나눌 수 있으며 특징은 다음과 같습니다.\nClass Component 1 2 3 4 5 6  //컴포넌트의 이름은 꼭 대문자로 시작 class Welcome extends React.Component { render() { return \u0026lt;h1\u0026gt;Hello, {this.props.name}\u0026lt;/h1\u0026gt;; } }    ES6의 Class 문법 사용 render() 메소드 사용 state, life cycle 기능 사용 임의 메소드 정의  Function Component 1 2 3 4 5 6 7 8 9 10  //컴포넌트의 이름은 꼭 대문자로 시작 function Welcome(props) { return \u0026lt;h1\u0026gt;Hello, {props.name}\u0026lt;/h1\u0026gt; } const Welcome = (props) =\u0026gt; { return ( \u0026lt;h1\u0026gt;Hello, {props.name}\u0026lt;/h1\u0026gt; ) }    state, life cycle 사용 불가 코드 작성시 간단한 장점 클래스 컴포넌트보다 상대적으로 메모리를 적게 사용 부가기능 없이 순수 결과 값 반환시 효율적  State 컴포넌트는 단방향으로 데이터 바인딩을 하며 데이터를 주고 받을 때 사용하는 props와 컴포넌트 내부에 사용하는 state가 있습니다. 그 중 state 는 클래스 컴포넌트가 활용하며 setState를 사용하여 데이터 변경이 가능합니다. 즉, 사용자 액션, 네트워크에 대한 응답 및 다른 요소의 응답으로 출력하는 기능을 뜻합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class App extends React.Component { state = { count : 0 } add = () =\u0026gt; { //this.state가 다른 위치에서 오염될 가능성이 있기에 current 인자를 활용하여 현재 영역의 count만 + 해준다.  //this.setState({count : this.state.count + 1}) -\u0026gt; 사용 x  this.setState(current =\u0026gt; ({ count : current.count + 1 })) } remove = () =\u0026gt; { this.setState(current =\u0026gt; ({ count : current.count - 1 })) } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;the number is : {this.state.count}\u0026lt;/h1\u0026gt; \u0026lt;button onClick={this.add}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.remove}\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } }   \nLife Cycle 리액트의 컴포넌트는 생명주기를 가지고 있습니다. 컴포넌트가 생성, 사용, 소멸할 때 까지의 과정을 뜻하며 이런 과정속에 특정한 시점에 자동으로 호출되는 메소드를 라이프 사이클 이벤트라고도 부릅니다.\n  mounting : 컴포넌트를 생성하는 것을 의미\n constructor : 생성자로 자바스크립트 클래스내 render() 메소드가 실행되기 전에 단 한번만 실행 render : 컴포넌트의 render() componentDidMount : 해당 메소드는 컴포넌트가 호출되어 render() 이후 실행    updating : 업데이트(수정 하는 것), 데이터나 이벤트등으로 변경할 때\n SholdComponentUpdate : 컴포넌트가 업데이트 되기 전 호출 메소드 render : 컴포넌트의 render() componentDidUpdate : setState를 호출 후 업데이트된 컴포넌트의 render 이후    unmounting : 종료(생명이 다하는 것)\n componentWillUnmount : 컴포넌트가 종료된 시점에 호출 메소드(DOM 제거 이후)    PropTypes 리액트의 타입 확인 기능을 담당하는 내장 라이브러리입니다. 컴포넌트의 prop의 타입을 확인할 때 사용하며 propTypes로 선언하여 사용합니다. 예를 들어 어떤 컴포넌트의 식별값을 name으로 했을때 보낸 props의 값이 name의 타입 및 특성을 체크하는 기능을 합니다. 사용하기 전 터미널에서 아래와 같은 명령어를 입력 후 package.json 에 다음과 같이 주입이 되었는지 확인합니다.\n npm i prop-types\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  import PropTypes from \u0026#34;prop-types\u0026#34;; //Clubs의 prop 타입 체크 function Clubs({ name, picture, rating }) { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;I like { name }\u0026lt;/h1\u0026gt; \u0026lt;h4\u0026gt;{ rating } / 5\u0026lt;/h4\u0026gt; \u0026lt;img alt={ name } src={ picture }/\u0026gt; \u0026lt;/div\u0026gt; ); } //Clubs 컴포넌트의 타입 체크 Clubs.protoTypes = { name : PropTypes.string.isRequired, //picture의 데이터타입은 string이고 require인지 확인  picture : PropTypes.string.isRequired, //rating prop의 타입이 number이며 require인지 확인, 아니라면 에러 표시  rating : PropTypes.number.isRequired }; const clubs = [ { id : 1, name : \u0026#34;chelsea\u0026#34;, image : \u0026#34;https://contents.sixshop.com/uploadedFiles/50779/product/image_1553506302388.png\u0026#34;, rating : 4.7 }, { id : 2, name : \u0026#34;liverpool\u0026#34;, image : \u0026#34;https://pluspng.com/img-png/logo-liverpool-fc-png-liverpool-fc-logo-500.png\u0026#34;, rating : 4.3 } ] function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;header className=\u0026#34;App-header\u0026#34;\u0026gt; \u0026lt;img src={logo} className=\u0026#34;App-logo\u0026#34; alt=\u0026#34;logo\u0026#34; /\u0026gt; {clubs.map(item =\u0026gt; ( \u0026lt;Clubs key={item.id} name={item.name} picture={item.image} rating={item.rating} /\u0026gt; ))} \u0026lt;/header\u0026gt; \u0026lt;/div\u0026gt; ); }   Router 리액트에서 사용하는 라우터는 react-router-dom 라이브러리를 사용합니다. 이 라이브러리는 기본적으로 URL을 가져와 비교하여 화면에 표시하게 됩니다. 예를 들어 / 와 /about 두개의 라우터코드를 작성하였습니다.\n1 2 3 4 5 6 7 8 9 10  import { HashRouter, Route } from \u0026#34;react-router-dom\u0026#34;; \u0026lt;HashRouter\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt;  \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;/about\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Introduction\u0026lt;/h1\u0026gt;  \u0026lt;/Route\u0026gt; \u0026lt;/HashRouter\u0026gt;   end-point를 /로 요청하였을 때 / 와 /about 둘 다 화면에 보여지게 됩니다. 요청에 대한 URL을 비교하게 되는데 / 는 Home과 Introduction 둘 다 path에 해당하기 때문입니다.\n결국 home 화면에서 여러 컴포넌트를 보여지게 되는 상황이 되는데 이를 구분 지을때는 exact 를 사용합니다. exact 는 URL의 경로가 정확히 맞는 컴포넌트만 보여주는 기능을 합니다.\n1 2 3 4 5 6 7 8 9 10  import { HashRouter, Route } from \u0026#34;react-router-dom\u0026#34;; \u0026lt;HashRouter\u0026gt; \u0026lt;Route exact path=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt;  \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;/about\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Introduction\u0026lt;/h1\u0026gt;  \u0026lt;/Route\u0026gt; \u0026lt;/HashRouter\u0026gt;   \nReference  https://academy.nomadcoders.co/courses/enrolled/216871 https://velog.io/@kyusung/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B5%90%EA%B3%BC%EC%84%9C-React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EC%83%81%ED%83%9C-%EA%B0%9D%EC%B2%B4 https://velog.io/@kyusung/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B5%90%EA%B3%BC%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8 https://ko.reactjs.org/docs/react-component.html https://velog.io/@parksj3205/%EB%A6%AC%EC%97%91%ED%8A%B8%EB%A5%BC-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EA%B8%B0%EC%88%A0-3-6%EC%9E%A5-%EC%A0%95%EB%A6%AC  ","description":"","id":4,"section":"posts","tags":["react"],"title":"리액트 시작 전 간단 정리","uri":"https://live-jh.github.io/posts/dev/react_info/"},{"content":"인터넷과 웹의 개념(인터넷 == 웹?)  각각의 개념을 어렴풋이 알고 있고 정확한 차이를 구분하지 못해 네트워크를 공부하면서 기억을 되살릴겸 확실한 개념정리를 위해 작성하였습니다. 잘못된 부분이 있다면 댓글로 알려주시면 감사하겠습니다 !\n  인터넷이란? 특정 지역의 제한된 컴퓨터들이 하드웨어적 네트워크를 가지고 통신하는 것을 인터네트워크라고 하며 이것은 인터넷의 시작이었으며 여러 통신망을 하나로 연결하여 자원을 공유한다는 의미에서 현재는 전 세계 컴퓨터들을 하나로 합치는 거대한 통신망을 말합니다.\n또한 인터넷은 클라이언트와 서버로 구성되어 있으며 TCP/IP(표준인터넷 프로토콜의 집합)라는 기본 프로토콜을 통해 제공됩니다.\n인터넷서비스의 종류는 WWW(월드 와이드 웹), E-Mail(전자우편), FTP(파일전송), Telnet(원격접속) 등이 있으며 현재는 Web이 가장 폭발적인 발전으로 대중적으로 널리 알려지게 되었습니다.\n 웹이란? WorldWide Web 이라 불리는 웹 은 인터넷에 연결된 사용자들이 정보를 공유할 수 있는 공간을 의미합니다. 팀 버너스리가 인터넷의 서비스중 E-Mail이나 FTP를 통해 주고받는 것을 비효율적이라 생각하여 제안한 공통된 공간의 정보를 공유하고 관리할 수 있는 시스템입니다. 과거의 HTML은 사용자가 요청한 HTML 페이지내에 텍스트 정보 전달 정도였지만 현재는 HTML의 기술발전과 함께 통신기술의 발달로 인해 텍스트를 포함한 이미지와 음성, 영상, 채팅, 대용량데이터처리까지 가능합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # Database # https://docs.djangoproject.com/en/3.0/ref/settings/#databases DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.postgresql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;force_of_habit\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;postgres\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;6h7j8k9l\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;force-of-habit.cmapp9o7soqr.ap-northeast-2.rds.amazonaws.com\u0026#39;, \u0026#39;PORT\u0026#39;: \u0026#39;5432\u0026#39; } }    웹을 지탱하고 구성하는기술  HTML (하이퍼미디어 포맷) HTTP (애플리케이션 컨트롤) URI (리소스 식별자)   HTTP (Hyper Text Transfer Protocol) Hyper Text는 직역하자면 초월적인 텍스트라는 의미입니다. (텍스트가 초월이동? 이런 느낌) 일반적 텍스트의 순차 접근법이 아닌 같은 페이지내에 다른 데이터로 이동하는 비순차적 접근법을 뜻하는 개념입니다. 이때 페이지에서 다른 페이지 혹은 문서 내부에서 다른 문서로 연결되는 참조를 하이퍼링크라고 말합니다. Transfer Protocol은 쉽게 말해 통신 규약(규칙)이라는 뜻으로 HTTP는 인터넷 통신망에서 리소스(자원)를 요청 및 응답에 사용되는 통신규약입니다.\nHTML (Hyper Text Markup Language) HTTP의 Hyper Text 의미는 동일하며 Markup은 표시하다라는 뜻으로 제목이나 표, 꼬리글, 문단 및 기타 요소를 이용해 구조적 표현을 하는 언어로써 웹 문서를 만드는 기능을 제공합니다. (ex : 회원가입시 데이터의 표기를 jhlee, South Korea 로 할 수 있지만 ID : jhlee, Country : South Korea로 제목을 붙여서 표현하는 것을 markup의 개념이라고 생각하면 이해가 조금 쉬울 수 있습니다.) 결론적으로 구조적 표현 언어를 통해 웹브라우저와 의사소통하고 정보가 담긴 웹 문서를 작성하는 기술입니다.\nURI (Uniform Resource Identifier) 직역하여 자원 식별자라는 뜻으로 웹에 존재하는 어떤 자원에 접근하기 위해 유일한 주소를 가진 식별자를 의미합니다. 자원의 종류는 이미지, 오디오파일, 동영상파일, 텍스트등을 말하며 사용자들은 웹브라우저에 웹사이트 주소를 입력하여 직접 URI정보를 지정할 수 있으며 이 주소 입력란에 입력된 정보를 URL(Uniform Resource Locator)이라고 합니다.\n 번외(웹의 기술적 특징 2가지) Hypermedia System (하이퍼미디어 시스템) 웹은 인터넷을 이용한 하이퍼미디어의 한 기본 예로 텍스트, 이미지, 음성, 영상등 다양한 미디어를 하이퍼링크로 구성한 시스템을 말합니다. HTML로 작성한 웹 페이지는 링크를 통해 다른 웹페이지로 연결하여 다양한 영상, 이미지, 텍스트등을 연결할 수 있습니다.\nDistributed System (분산 시스템) 웹은 프로토콜이 심플하며 전 세계에 배치된 서버에 모든 브라우저가 접속할 수 있는 분산 시스템을 말합니다.\n 정리 웹은 클라이언트가 웹사이트의 주소와 페이지를 요청시 웹페이지의 URI(전송할 자원이 어디에 위치하는지 표현하는 식별자)를 기반으로 연관 서비스를 제공하는 서버를 찾습니다. 서버는 요청에 따른 웹페이지의 HTML(하이퍼텍스트를 통해 작성된 정보나 문서)를 응답하면서 HTTP(문서를 보낼때 정보 처리를 위한 전송 규약)을 토대로 전송하게 됩니다.\n웹은 전자 메일이나 파일 전송과 같은 인터넷상에 동작하는 하나의 서비스로 인터넷 구조에서 가장 발전하고 대중적인 서비스입니다. 인터넷은 통신망(네트워크와 네트워크간의 연결)이라 이해하고 표현하는게 적절하며 웹은 그 서비스중 하나로 이해하면 됩니다.\n","description":"","id":5,"section":"posts","tags":[""],"title":"인터넷과 웹의 개념 차이","uri":"https://live-jh.github.io/posts/dev/web_base/"},{"content":"네트워크 기초지식 학습 정리  비전공자로 웹개발자가 되기 위해 적지만 여러 회사를 면접을 보며 기술면접에서 부족한 부분을 채워 나가야겠다라는 생각을 하게 되었고 네트워크에 대해 한번쯤 들어본 단어 및 내용에 대해 학습하고 내 것으로 만들기 위해 정리하는 글입니다.\n 네트워크란(Network)? Net와 Work의 합성어로 쉽게 말해 작업망이란 개념을 가지고 있습니다. 예를 들어 도로망이나 전화망, 물류망을 떠올려보면 그물처럼 연결되어 있는 모습을 생각하면 이해하기 쉽습니다. 이처럼 네트워크란 단어의 뜻은 다양한 분야에서 사용이 되고 있으며 IT분야에선 네트워크란 무엇(A)과 무엇(B)이 그물망처럼 무언가에 의해 연결되어 운반할 수 있는 상태를 말합니다. 점과 점 그리고 연결된 연결선을 통한 무엇을 운반하는 개념으로 점은 node라고 흔히 불리며 선은 link라고 부릅니다.\n컴퓨터 네트워크에 대해 네트워크에 개념을 빌려 표현을 하자면 무엇(A)과 무엇(B)이 뜻하는 것은 컴퓨터로 볼 수 있고 무언가에 의해를 의미하는 것은 통신매체입니다. 마지막으로 운반할 수 있는 상태에 대해서 운반의 대상이 되는 것은 **정보(데이터)**라고 볼 수 있습니다. 정리를 하자면 컴퓨터와 컴퓨터가 그물망처럼 통신매체로 연결되어 정보를 주고 받는 것을 컴퓨터 네트워크라고 말할 수 있습니다.\n네트워크를 사용하는 이유는 하나의 컴퓨터에서 하는 일과 필요한 자원(Resource)을 다수의 컴퓨터에 공유할 수 있기 때문입니다. 쉽게 예를 들어 하나의 파일을 다수가 공유함으로써 일을 나눠 처리할 수 있으며 프린터공유나 파일공유, 홈페이지를 통한 정보 교환등이 네트워크의 장점에 해당합니다.\n데이터 통신? 데이터는 무언가에 의해 정보를 컴퓨터상 표현한 것으로 자원(Resource)을 공유하기 위해 사용하는 것을 의미합니다. 네트워크에서 정보는 비트(Bit)단위 즉, 0과1로 구성이 되고 저장이 되는 것을 말하며 이러한 데이터를 보내고 받는 것을 데이터 통신이라 말합니다. 이러한 데이터 통신에는 둘을 연결할 수 있는 통신 매체(연결선의 중개)가 필요한데 이것을 인터페이스라 부르며 인터페이스를 통해 데이터를 주고 받는 규칙을 정하여 통신을 하는 것을 프로토콜이라 말합니다. 비유하자면 미국의 1달러와 영국의 1파운드가 다르듯 송수신간에 같은 프로토콜을 사용해야 하는 것을 의미합니다. (A라는 마을에서 햄버거 1개를 사과 10개로 교환할 줄 알고 보냈는데 B라는 마을에서는 햄버거 1개가 사과 5개인 상황을 맞이해선 안되기 때문이죠.)\n회선교환과 패킷교환  위에 데이터통신은 예시로 1대1의 경우를 설명했지만 다수의 컴퓨터들과도 송수신을 하고 싶을때는 어떻게 해야할까요?\n 다수의 컴퓨터들과 데이터 통신은 교환기를 통해 연결이 가능합니다. 연결하고자 하는 다수의 컴퓨터들과 파이프(회선) 사이에 교환기를 위치시켜 파이프를 교환하여 전송하는 방식을 회선교환이라 말합니다. 이러한 방식으로 10대, 100대, 1000대등 많은 양의 컴퓨터들의 데이터통신이 가능합니다. 하지만 많은 컴퓨터들이 통신을 하기 위해선 회선의 수가 많아질 수 밖에 없는 단점을 가지고 있습니다. 이러한 단점을 보완하고 다수의 컴퓨터들이 자유롭게 정보를 송수신하기 위해 사용하는 것은 패킷교환이라 말합니다. 패킷교환이란 데이터를 송수신할때 데이터를 한번에 보내는 것이 아니라 여러 조각으로 분할하여 보내는 방식을 뜻합니다. 큰 데이터를 작게 나누어 송수신을 하여 패킷 1개를 전송할때 보내는 시간이 짧아지며, 그 시간이 짧아짐에 따라 회선을 점유하는 시간이 짧아지기때문에 다수의 컴퓨터가 회선을 공유할 수 있게 되는 것입니다. 또한 송신처에서 패킷을 분할할때 순번을 지정하여 보내며 수신처에선 그 순번을 통해 패킷을 다시 재결합하여 사용하게 되는데 이것을 단편화, 재결합이라 말합니다.\nReference  하루3분네트워크교실  ","description":"","id":6,"section":"posts","tags":[""],"title":"네트워크 용어 정리 및 기초","uri":"https://live-jh.github.io/posts/dev/network_base/"},{"content":" 드림코딩 엘리 강좌를 보며 유용한 것들에 대해 정리한 내용 2입니다.\n요약해서 간단히 정리한 내용이므로 빠진 부분이 있을 수 있습니다.\n 1. hoisting 사전적 의미는 끌어올리다라는 뜻으로 실제 자바스크립트 엔진이 자체적으로 코드 전반에 선언된 모든 것들을 발견시 위로 끌어 올려 함수나 변수에 할당하여 실행할 수 있는 환경을 갖추는 것을 말합니다.\n유효범위는 보통 함수 {} 내에서 유효하며 var 선언과 함수선언문 에만 적용됩니다.\n1 2 3 4 5 6 7 8 9 10 11  //hoisting console.log(num) // undefined -\u0026gt; undefined 할당 num = 10; var num; console.log(num) // 10  { score = 20; var score; } console.log(score); //20 {} 영향을 받지 않는다.   \n2. class get, set 클래스는 객체지향 프로그래밍에서 객체를 생성하기 위한 정의를 말합니다. 예를 들어 회원가입이란 기능이 있다고 가정했을때 회원 하나가 객체라고 볼 수 있습니다. 회원이 가진 특징을 나열해 보면 이름, 나이, 이메일, 생년월일, 아이디 등등이 있을 수 있고 회원이 행동하는 것은 조회, 가입, 탈퇴, 수정등이 있습니다. 이것들을 정의하는 틀을 클래스라 말하며 클래스를 통해 여러 회원을 생성할 수 있는데 이는 인스턴스라고 말합니다.\n class: template\nobejct: instance of a class\n ※ 쉽게 이해하는 캡슐화와 get\u0026amp;set의 필요성 생성한 인스턴스의 필드의 속성을 가지고 역할을 수행할 때 우리는 해당 필드의 변조 방지 또는 제한 범위가 필요할 수도 있습니다. 예를 들어 축구팀이라는 클래스가 있을 때 구단내에 최소 스태프는 0명이며 구단 선발 명단은 11명의 조건이 필요합니다. 스태프에 대한 음수(-1)는 다룰 수 없기 때문에 이를 데이터를 보다 안전하게제어하기 위한 수단으로 setter를 사용하여 데이터를 조작하고 getter로 사용합니다. 마지막으로 캡슐화를 하는 이유는 필드 staff, player 특징상 축구팀 클래스 자체의 고유한 성향 때문에 private을 선언하며 다른 영역에서 침범하여 사용할 수 없도록 하기 위함입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Person { constructor(name, age) { this.name = name; this.age = age; } get age() { return this._age; } set age(value) { this._age= value // age -\u0026gt; Maximum call stack size exceeded  } } const user1 = new Person(\u0026#39;mount\u0026#39;, 21); console.log(user1)   \n3. public, private Fields  ※ 아직 safari에서 지원하지 않는다.\n 1 2 3 4 5 6 7 8  class Test { publicValue = 2; #privateValue = 10; } const test = new Test(); console.log(test.privateValue) // undefined console.log(test.publicValue) // 2   \n4. static properties \u0026amp; method static은 클래스 자체적으로만 접근할 수 있기 때문에 인스턴스(객체)와 무관하게 공통적으로 클래스 내에서만 사용해야 할 때 유용하며 메모리의 사용도 줄여줄 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11  class Article { static backend = \u0026#39;hello python\u0026#39; static printBackend() { console.log(Article.backend) } } const article = new Article(); console.log(article.backend) // undefined console.log(Article.backend) // hello python   \n5. extends 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Shape { constructor(width, height, color) { this.width = width; this.height = height; this.color = color; } draw() { console.log(`drawing ${this.color}`) } getArea() { return this.width * this.height; } } class Rectangle extends Shape {} class Triangle extends Shape { //overriding -\u0026gt; 오버라이딩으로 인해 triangle에 draw가 호출된다.  draw() { console.log(\u0026#34;triangle overriding\u0026#34;) } } const rectangle = new Rectangle(5,2,\u0026#39;red\u0026#39;) const triangle = new Triangle(2,3,\u0026#39;black\u0026#39;) triangle.draw() console.log(rectangle.getArea())   \n6. async \u0026amp; await async와 await는 promise를 조금 더 간결하게 사용하고 동기적으로 실행되는 것처럼 코드를 작성할 수 있게 도와주는 역할을 합니다.\npromise에 대한 자세한 내용은 비동기 및 콜백함수 에서 확인할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  function fetchUser() { return new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#34;havartz\u0026#34;) }) } const user = fetchUser(); user.then(console.log) async function fetchUser() { //-\u0026gt; 위 promise 기능을 async로 대신한다.  return \u0026#34;havartz\u0026#34; } const user2 = fetchUser(); user2.then(console.log) function delay(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)) } async function getKiwi() { await delay(2000); // 2초동안 기다린 후 아래 kiwi 리턴  return \u0026#34;kiwi\u0026#34;; } async function getLemon() { await delay(2000); // 2초동안 기다린 후 아래 kiwi 리턴  return \u0026#34;lemon\u0026#34;; } async function getFruits() { //병렬 처리(한번에 처리)  const kiwiPromise = getKiwi(); const kiwi = await kiwiPromise const lemonPromise = getLemon(); const lemon = await lemonPromise //Promise All api  return Promise.all([getKiwi(), getLemon()]).then(fruits =\u0026gt; fruits.join(\u0026#39;, \u0026#39;)) //먼저 처리되는 것을 불러올때 race 사용  return Promise.race([getKiwi(), getLemon()]); } getFruits().then(console.log)    Reference  나무위키 드림코딩 by 엘리 인사이드자바스크립트  ","description":"","id":7,"section":"posts","tags":["javascript","자바스크립트"],"title":"자바스크립트 알아두면 좋을 기초 개념 요약","uri":"https://live-jh.github.io/posts/dev/js_basic_concept/"},{"content":" 드림코딩 엘리 강좌를 보며 유용한 것들에 대해 정리한 내용입니다.\nAPI or Document를 읽고 보는 습관을 만들기 👍🏻\n 1. read API 1 2 3 4 5  // Ex // 2개의 파라미터 (첫번째 callback 함수, thisArg? -\u0026gt; ?는 파라미터를 선택적으로 지정 가능) // 이해가 잘 안될땐 console.log로 파라미터 확인하기 forEach(callbackfn: (value: T, index: number, array: T[]) =\u0026gt; void, thisArg ?: any): void;   \n2. parameters  Premitive parameters : passed by value\nObject parameters : passed by reference\ndefault parameters : undefined\nrest parameters\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function _onChange(obj, obj2) { obj.power = \u0026#39;on\u0026#39;; console.log(obj2) // =\u0026gt; undefined } const desktop = {power : \u0026#34;off\u0026#34;}; _onChange(desktop); console.log(desktop); //power on  //rest parameters is_print(1,2,3); function is_print(...args) { for(arg of args) { console.log(arg) //1 2 3  } }   \n3. early return \u0026amp; arrow function 1 2 3 4 5 6 7 8 9 10 11 12 13  //early return function updatePost(post) { //해당 조건이 아닐 때에는 return을 하여 종료 후 다음 로직을 실행하도록 하는 것이 더욱 효과적 \tif(post.like \u0026lt; 100) { return; } //do Something.. } //arrow function (함수 선언 방법중 하나) const check_console = () =\u0026gt; console.log(\u0026#34;done\u0026#34;); // return 생략 가능 const sum = (a, b) =\u0026gt; a + b;   \n4. for-loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] for(let i = 0; i \u0026lt; fruits.length; i++) { console.log(fruits[i]); } for(let fruit of fruits) { console.log(fruit) } fruits.forEach(function(fruit, index) { console.log(fruit) }); //forEach arrow로 변경하기 (한줄 작성시 {} 생략가능) fruits.forEach((fruit) =\u0026gt; console.log(fruit));   \n5. add, delete, copy 5-1. push : 아이템을 맨 끝에 추가 1 2 3  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] fruits.push(\u0026#39;melon\u0026#39;) console.log(fruits) //[ \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;melon\u0026#39; ]   5-2. pop : 아이템을 맨 뒤부터 제거 1 2 3 4  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] fruits.pop() fruits.pop() console.log(fruits) //[ \u0026#39;apple\u0026#39;]   5-3. unshift : 아이템을 맨 앞에 추가 1 2 3  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] fruits.unshift(\u0026#39;kiwi\u0026#39;) console.log(fruits) //[ \u0026#39;kiwi\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39; ]   5-4. shift : 아이템을 맨 앞부터 제거 1 2 3  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] fruits.shift() console.log(fruits) //[ \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39; ]   \n※ Tip shift와 unshift는 맨 앞쪽에 데이터를 추가 및 제거를 하는데 이는 전체 데이터들의 이동(step의 증가)이 필요하기 때문에 pop과 push에 비해 속도가 현저히 느리다는 단점을 가지고 있다.\n5-5. splice : 지정한 인덱스의 데이터를 제거 1 2 3 4 5 6 7  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] fruits.splice(1) // (start_index, delete_count) 이때 delete_count를 지정하지 않는다면 start_index를 제외한 모든 데이터를 제거한다. console.log(fruits) //[ \u0026#39;apple\u0026#39; ]  fruits.splice(0, 1, \u0026#39;kiwi\u0026#39;, \u0026#39;mango\u0026#39;) //0번 인덱스의 1개를 지우고 kiwi, mango를 추가 console.log(fruits) //[ \u0026#39;kiwi\u0026#39;, \u0026#39;mango\u0026#39; ]   5-6. concat : 배열 합치기 1 2 3 4 5 6 7  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] const fruits2 = [\u0026#39;kiwi\u0026#39;, \u0026#39;mango\u0026#39;] const newFruits = fruits.concat(fruits2); //concat(...items: ConcatArray\u0026lt;T\u0026gt;[]): T[]; 새로운 배열 return  console.log(newFruits);   5-7. indexOf : 데이터 인덱스 찾기 \u0026amp; includes : 인덱스 T/F 확인 1 2 3 4  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] console.log(fruits.indexOf(\u0026#39;apple\u0026#39;)); // 0 console.log(fruits.includes(\u0026#39;kiwi\u0026#39;)); // false console.log(fruits.includes(\u0026#39;orang\u0026#39;)); // true   5-8. listIndexOf : 마지막 인덱스의 자료 찾기 1 2 3  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;apple\u0026#39;] fruits.indexOf(\u0026#39;apple\u0026#39;) //0 fruits.listIndexOf(\u0026#39;apple\u0026#39;) // 3   Quiz 1. 배열 -\u0026gt; 문자열 1 2 3  const fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;apple\u0026#39;] const result = fruits.join(\u0026#39;,\u0026#39;); console.log(result) //apple,banana,lemon,apple   2. 문자열 -\u0026gt; 배열 1 2 3  const fruits = \u0026#39;apple,lemon,kiwi\u0026#39;; const result = fruits.split(\u0026#39;,\u0026#39;); //두번째 파라미터 limit(개수) console.log(result) // [apple, lemon, kiwi]   3. 배열 순서 변경 1 2 3  const numbers = [5,4,3,2,1]; const reverse_result = numbers.reverse(); //배열 자체를 리턴 console.log(rev_numbers)   4. 지정한 인덱스까지 자르기 1 2 3 4 5 6 7 8  const arr = [1,2,3,4,5]; const result = arr.splice(1,3); //1번 인덱스부터 총 3개 자르기 console.log(result) //(2,3,4) console.log(arr) // 삭제되고 남은 배열  const arr2 = [\u0026#39;chelsea\u0026#39;, \u0026#39;arsenal\u0026#39;, \u0026#39;liverpool\u0026#39;]; const result2 = arr2.slice(0,2); // [\u0026#39;chelsea\u0026#39;, \u0026#39;arsenal\u0026#39;] console.log(arr2) // 원본 유지   5. 조건에 맞는 데이터 찾기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Player { constructor(name, age, number, team) { this.name = name, this.age = age, this.number = number, this.team = team } } const players = [ new Player(\u0026#39;abraham\u0026#39;, 30, 9, \u0026#34;sec\u0026#34;), new Player(\u0026#39;pulisic\u0026#39;, 21, 10, \u0026#34;fir\u0026#34;), new Player(\u0026#39;Kante\u0026#39;, 25, 7, \u0026#34;fir\u0026#34;),\tnew Player(\u0026#39;mount\u0026#39;, 28, 19, \u0026#34;sec\u0026#34;), ] const result = players.find((player) =\u0026gt; player.age \u0026lt; 25); console.log(result) // pulisic 조건에 맞는 데이터를 리턴하고 종료   6. 객체 속성의 배열에서 조건에 맞는 키값의 데이터 배열 만들기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Player { constructor(name, age, number, team) { this.name = name, this.age = age, this.number = number, this.team = team } } const players = [ new Player(\u0026#39;abraham\u0026#39;, 30, 9, \u0026#34;sec\u0026#34;), new Player(\u0026#39;pulisic\u0026#39;, 21, 10, \u0026#34;fir\u0026#34;), new Player(\u0026#39;Kante\u0026#39;, 25, 7, \u0026#34;fir\u0026#34;),\tnew Player(\u0026#39;mount\u0026#39;, 28, 19, \u0026#34;sec\u0026#34;), ] const result = players.filter((player =\u0026gt; player.team === \u0026#39;sec\u0026#39;)) console.log(result) //[Player { name: \u0026#39;abraham\u0026#39;, age: 30, number: 9, team: \u0026#39;sec\u0026#39; }, Player { name: \u0026#39;mount\u0026#39;, age: 28, number: 19, team: \u0026#39;sec\u0026#39; }]   7. 조건에 맞는 필드값의 배열 리턴하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Player { constructor(name, age, number, team) { this.name = name, this.age = age, this.number = number, this.team = team } } const players = [ new Player(\u0026#39;abraham\u0026#39;, 30, 9, \u0026#34;sec\u0026#34;), new Player(\u0026#39;pulisic\u0026#39;, 21, 10, \u0026#34;fir\u0026#34;), new Player(\u0026#39;Kante\u0026#39;, 25, 7, \u0026#34;fir\u0026#34;),\tnew Player(\u0026#39;mount\u0026#39;, 28, 19, \u0026#34;sec\u0026#34;), ] const result = players.map((player =\u0026gt; player.number)) console.log(result) //[ 9, 10, 7, 19 ]   8. 평균값 구하기(나이 평균) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Player { constructor(name, age, number, team) { this.name = name, this.age = age, this.number = number, this.team = team } } const players = [ new Player(\u0026#39;abraham\u0026#39;, 30, 9, \u0026#34;sec\u0026#34;), new Player(\u0026#39;pulisic\u0026#39;, 21, 10, \u0026#34;fir\u0026#34;), new Player(\u0026#39;Kante\u0026#39;, 25, 7, \u0026#34;fir\u0026#34;),\tnew Player(\u0026#39;mount\u0026#39;, 28, 19, \u0026#34;sec\u0026#34;), ] const player_result = players.reduce((prev, current) =\u0026gt; prev + current.age, 0); //prev default value =\u0026gt; 0  console.log(player_result/players.length) // 26  //add some, every const result = players.some((player =\u0026gt; player.age \u0026gt; 19 \u0026amp;\u0026amp; player.age \u0026lt; 30)) const result2 = !players.every(player =\u0026gt; player.number \u0026lt; 6) //some : 배열의 요소에서 콜백함수의 리턴이 true인지 false인지 체크 (단 하나의 조건이라도 만족하면 true, 아니면 false)  const result2 = !players.every(player =\u0026gt; player.number \u0026lt; 6) console.log(result2) //evrey : 검색하고자 하는 전체의 조건이 다 만족하면 true, 아니면 false    9. 해당 조건에 맞는 데이터를 문자열 형태로 반환하기 1 2 3 4 5  const last_result = players.map((player) =\u0026gt; player.number) .filter((number) =\u0026gt; number \u0026gt; 7) .join(\u0026#34;,\u0026#34;); console.log(last_result) //9,10,19   \nReference  드림코딩엘리  ","description":"","id":8,"section":"posts","tags":["자바스크립트","javascript"],"title":"자바스크립트 함수, 배열 및 APIs 정리","uri":"https://live-jh.github.io/posts/dev/javascript_apis/"},{"content":"aws로 웹서버 구성하기 정리 요약-2  생활코딩 및 jojoldu 님의 블로그를 보며 학습한 내용을 정리한 글입니다.)\n목차 1, 2는 이전 aws로 웹서버 구성하기 정리 요약-1 글을 확인해주시면 됩니다.\n 목차 1. 회원가입 2. 인스턴스 생성 3. 탄력 IP 등록 4. 터미널을 통해 EC2 접속 3. 탄력 IP 등록 인스턴스를 생성 후 우리는 탄력 IP(Elastic IP)를 등록해야 합니다.\nwhy?\nAWS에서는 EC2의 인스턴스를 중지/시작할 때마다 유동적으로 IP가 바뀌게 됩니다. 만약 고정적 IP를 하지 않는다면 인스턴스를 중지 후 재시작할 때마다 IP가 변경됨으로 인해 앱을 업데이트를 해줘야 하며 기존의 도메인 주소로도 접속할 수 없는 불편한 현상을 맞이하게 됩니다. 이런 문제를 해결하기 위해 Elastic IP를 설정할 수 있으며 이는 고정적 IP를 지정함으로써 불편함을 해결할 수 있는 장점이 있지만 몇가지 유의해야 하는 점이 있습니다.\n과금 조건   탄력적 IP 주소가 EC2 인스턴스와 연결되어 있는 상태\n  탄력적 IP 주소와 연결된 인스턴스가 실행 중일때\n  인스턴스에 연결된 탄력적 IP 주소가 하나일 때\n  주소가 BYOIP 주소 풀에 포함된 주소일 때\n​\n  이러한 조건을 충족하지 않는 탄력적 IP 주소는 각각 시간당 과금이 발생합니다. 자세한 내용은 탄력적 IP 요금에 대한 이해 참고\n밑에 사진처럼 탄력적 IP를 클릭하면 나오는 페이지 중앙에 새주소 할당 버튼을 클릭합니다.\n페이지에서 할당 버튼을 클릭하면 새주소 요청 성공이란 메세지와 함께 탄력적 IP가 생성되는 것을 확인할 수 있습니다.\n닫기버튼을 눌러줍니다.\n자 이제 생성된 탄력적 IP 위에 마우스 오른쪽 클릭 후 주소 연결을 선택합니다.\n주소를 연결할 인스턴스와 프라이빗IP를 선택해줍니다. 처음 AWS를 시작하는 분들은 포스팅을 통해 따라한 인스턴스 하나만 존재하기에 그대로 생성한 인스턴스를 선택하면 되지만 기존에 사용하던 인스턴스가 여러개라면 사용하고자 하는 인스턴스를 선택해주시면 됩니다.\n연결이 완료되면 탄력적 IP 리스트에 인스턴스와 할당 ID, 프라이빗 IP주소가 연결되어 있는것을 확인 할 수 있고 밑에 사진과 같이 인스턴스 탭에선 탄력적 IP가 연결되어 있는 것을 확인할 수 있습니다.\n4. 터미널을 통해 EC2 접속 간략 목차  다운받은 SSH pem key 권한 변경 및 폴더 설정 터미널을 통해 EC2 접속  4-1. 폴더 설정\n접속하기 전에 SSH pem key의 폴더 경로 설정 및 권한을 변경해줘야 합니다.\n저는 개인적으로 터미널에서 폴더 설정 및 권한 변경을 리눅스 명령어를 통해 진행하였으나 리눅스 명령어가 어색하신 분들은 생활코딩 에서 더욱 이해하기 쉽게 폴더 경로 설정 및 권한 설정하는 부분을 알려주니 생활코딩을 참고하시길 바랍니다 !\n저는 밑에 사진처럼 경로를 설정하여 pem key를 따로 보관하였습니다.\n4-2. 권한 변경\naws 인스턴스 메뉴 탭을 누르면 생성된 인스턴스를 확인할 수 있는데 마우스 우클릭 후 연결을 누릅니다.\n연결을 누른 후 인스턴스에 연결이란 이름의 모달창을 볼 수 있습니다. 엑세스 방법에 대한 설명을 보고 이제 따라해보겠습니다.\n terminal을 실행합니다. SSH pem key를 저장한 폴더로 이동합니다. (ex: cd 폴더 경로명) 후 엔터 ls를 입력하여 pem key 가 잘 있는지 확인합니다. (pem key의 파일이 존재하면 됩니다.) 모달창에 목차 3번의 \u0026lsquo;chmod 400 SSH키명.pem\u0026rsquo; 복사 (밑에 사진 참고) 후 terminal에 입력합니다. 밑에 사진의 2. 복사 부분의 ssh 명령어를 복사 후 4번과 동일하게 terminal에 입력합니다.  Are you sure you want to continue connecting (yes/no)? -\u0026gt; yes 입력 Amazon Linux AMI welcome !  종료는 exit를 입력하면 됩니다. 매번 SSH pem key를 입력하기 번거롭기에 이 부분을 설정하는 방법은 jojoldu님 블로그를 참고하여 따라하시면 됩니다.\n정리 생활코딩 강좌를 한번 정독하셨다면 손쉽게 따라오실 수 있을만한 내용이라고 생각합니다. 검색하면 그만큼 자료와 정보가 많았으며 저 또한 처음은 과금이란 단어가 무서워 이것저것 손도 못댔지만 너무나 좋은 강좌와 블로그들로 인해 잘 구현할 수 있었고 여기까지 진행하면서 평소 맥을 사용하기에 리눅스 명령어를 조금이나마 익혀둔 것을 사용하면서 뿌듯함을 느끼기도 하였습니다. 이제 겨우 인스턴스를 생성하고 접속한 것이기 때문에 개인적으로 Hello world를 콘솔창에 띄운 것과 같은 느낌입니다.\n","description":"","id":9,"section":"posts","tags":["aws"],"title":"따라하며 익히는 aws로 웹서버 구성하기 정리 2","uri":"https://live-jh.github.io/posts/dev/aws_web_service_beginner_2/"},{"content":"aws로 웹서버 구성하기 정리 요약-1  생활코딩 및 jojoldu 님의 블로그를 보며 학습한 내용을 정리한 글입니다.)\n 목차 1. 회원가입 2. 인스턴스 생성 3. 탄력 IP 등록 4. 터미널을 통해 EC2 접속 1. aws 회원가입 생활코딩 강좌를 통해 쉽게 회원가입할 수 있습니다. 초보분들도 쉽게 할 수 있기에 따로 정리하지 않았습니다.\n2. 인스턴스 생성 오른쪽 상단에 위치한 Region을 확인해서 서울이 아니면 서울로 변경해줍니다. Region에 대한 정보는 이전에 올린 aws 기초 용어 및 개념 글을 보면 도움이 되실 겁니다. 이해가 잘 안된다면 생활코딩 강좌를 정독하는 것을 권해드립니다.\n이후 메인에 보이는 솔루션 구축 탭에 EC2를 사용하여 를 클릭하여 인스턴스를 바로 생성하겠습니다.\n2-1. Amazon Machine Image (AMI)\n단계 1 : 쉽게 말해 운영체제와 같다고 생각하면 됩니다. 구현하고자 하는 서비스에 따라 유용한 os를 선택하게 되는데 저는 Amazon Linux AMI (HVM) 를 선택하였습니다. (내부적 Centos는 동일합니다.)\n2-2. 인스턴스 유형 선택\n단계 2 : t2.micro를 선택하고 다음 : 인스턴스 세부 정보 구성 을 눌러줍니다.\n2-3. 인스턴스 세부 정보 구성\n단계 3 : 인스턴스의 갯수는 1개로 입력해주고 다음 : 스토리지 추가를 눌러줍니다.\n각 요구사항을 간단히 요약하자면 구매 옵션(스팟 인스턴스 - 인스턴스의 비활성화/활성화에 따른 효율적 과금), 네트워크(네트워크 옵션), 종료 방식(인스턴스의 terminated 방식 옵션), 모니터링(세부 모니터링) 등 있습니다.\n2-4. 스토리지 추가\n단계 4 : 볼륨 유형에서 ssd란 옵션을 통해 유추할 수 있지만 스토리지란 pc의 저장장치와 같습니다.\n즉 인스턴스의 저장장치를 뜻하며 페이지 하단에 안내처럼 최대 30GB까지 무료로 사용할 수 있습니다.\n2-5. 태그 추가\n단계 5 : 인스턴스의 키를 설정하는 것을 말합니다. 식별자와 비슷한 개념으로 인스턴스들을 태그로 구분지어 효율적 관리를 하기 위한 기능입니다.\n2-6. 보안 그룹 구성\n단계 6 : 가장 중요한 보안그룹 페이지입니다. 말 그대로 내 인스턴스의 접속에 대한 보안에 관련된 옵션을 설정하는 부분이라 과금과도 직접적으로 영향을 미칠 수 있으니 유의해야 하는 부분입니다. SSH는 터미널을 사용해 EC2에 접속할 때 사용하는 포트로써 직접 관리하는 사람 외에 아무나 접근하면 안되기 때문에 소스옵션을 내 IP로 변경해줍니다.\n 추가적으로 다른 SSH를 설정하려면 규칙 추가 버튼 누른 후\n사용자 지정 옵션을 지정하고 다른 PC의 IP를 입력하면 됩니다.\n 우리는 사용자들이 웹 브라우저를 통해 접속할 수 있는 웹서버를 구현할 예정이기 때문에 그에 따른 프로토콜인 HTTP/HTTPS를 추가해줍니다. 추가후 소스에 대한 부분은 밑에 사진처럼 소스 옵션을 지정해줍니다.\n만약 HTTP/HTTPS에 대한 소스를 내 IP로 지정한다면 다양한 사용자가 아닌 나 자신 Local IP로만 접속이 가능하기 때문에 이 점 유의해서 SSH 와 HTTP/HTTPS를 구분지어 설정해주셔야 합니다.\n2-7. 인스턴스 시작 검토\n단계 7 : 지금까지 설정한 인스턴스를 시작하기전 마지막 검토를 하는 부분입니다.\n잘 따라오셨다면 살포시 바로 시작하기 버튼을 눌러주시면 됩니다.\n시작하기 버튼을 누르면 작은 모달 창이 하나 뜨면 밑에 사진처럼 순서대로 진행해주시면 됩니다. 키 페어 이름은 아무렇게 기억하기 편하게 입력해주시면 됩니다. 키페어는 나중에 SSH로 EC2에 접속하기 위해 꼭 필요한 부분이니 다운받은 후 잘 고이 모셔둡니다.\n키페어를 다운로드하면 인스턴스 시작 버튼이 활성화되고 활성화된 버튼을 눌러주면 인스턴스를 시작하는 페이지가 뜨면서 인스턴스가 생성된 것을 확인할 수 있습니다.\nEC2 대시보드에서 인스턴스의 상태가 running으로 되어 있으면 정상적으로 생성 및 실행이 되고 있는 것입니다. 친절하게 메일까지 오네요 :)\n정리 목차 3, 4는 다음에 포스팅할 예정입니다. 비전공자가 개발자로 일하기 위해 혼자 독학으로 삽질하며 발품팔아 이것 저것 보고 습득하느냐 부족하거나 잘못된 정보가 많을 수 있습니다. 개념에 대해서 저만의 방식으로 이해를 위해 요약한 부분도 있기 때문에 이런 부분이 잘못되어 있다면 댓글로 알려주시면 감사하겠습니다 :)\n","description":"","id":10,"section":"posts","tags":["aws"],"title":"따라하며 익히는 aws로 웹서버 구성하기 정리 1","uri":"https://live-jh.github.io/posts/dev/aws_web_service_beginner_1/"},{"content":"aws linux 1 서버 초기 설정  스프링 부트와 AWS로 혼자 구현하는 웹서비스 도서를 보고 정리한 내용입니다.\n  타임존 변경(미국시간 -\u0026gt; 한국시간) 호스트네임 변경(접속한 Console의 서버명)  타임존 변경 EC2 서버의 기본 타임존은 세계 표준 시간인 UTC입니다. 타임 존을 변경하지 않으면 서버에 생성된 모든 시간은 UTC 기준으로 반영되기 때문에 한국 시간대로 변경을 해주어야 합니다.\nEC2에 접속한 상태에서 아래와 같은 명령어를 입력합니다.\n sudo rm /etc/localtime\nsudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime\n 명령어를 입력 후 date를 입력하여 타임존이 KST로 변경된 것을 확인하면 작업은 마무리됩니다.\n호스트네임 변경 호스트네임이란 접속한 서버를 구분할 수 있도록 표현하기 위한 설정으로 위에 콘솔창 그림처럼 접속 유저와 그에 따른 호스트네임으로 해당 서버를 표시할 수 있습니다. 아래와 같이 명령어를 입력하여 편집파일을 실행합니다.\n sudo vi /etc/sysconfig/network\n i 를 눌러 화면에 표시된 HOSTNAME 부분을 원하는 호스트네임으로 수정하고 :wq 를 입력하고 엔터를 눌러 수정된 파일을 저장하고 나옵니다. 변경 후 다음과 같은 명령어를 입력하여 서버를 재부팅하고 재부팅이 끝난 이후 다시 EC2에 접속해보면 호스트네임이 변경된 것을 확인 할 수 있습니다.\n sudo reboot\n 이후 호스트 주소를 찾을 때 /etc/hosts에 검색할 수 있도록 아래 명령어를 입력하여 등록을 해야합니다.\n sudo vi /etc/hosts\n 위 명령어를 통해 열린 파일내에 127.0.0.1 등록한HostName 을 추가시켜주고 :wq 를 입력하고 저장하여 파일을 종료합니다. 마지막으로 잘 등록이 되었는지 확인 하는 작업은 아래와 같이 명령어를 입력하면 됩니다.\n curl 등록한HostName\n 등록이 잘 되었다면  (7) Failed to connect to springboot2-webservice port 80: 연결이 거부됨 이란 메세지가 나오게 됩니다.\nReference  https://jojoldu.tistory.com/463  ","description":"","id":11,"section":"posts","tags":["aws"],"title":"aws lunux 1 서버 초기 설정하기","uri":"https://live-jh.github.io/posts/dev/aws_ec2_setting/"},{"content":"동기/비동기 처리란? 동기 처리 모델은 직렬적으로 작업을 수행하는 것을 말합니다. 보통 우리는 코드를 작성할 때 위에서 아래로 순차 실행을 기대하는데 이를 동기 처리 모델이라 합니다. 순차적으로 실행할 때 먼저 시작한 작업이 실행중이라면 다음 작업은 대기하게 되는 특성을 가지고 있습니다. 동기 처리는 서버에 요청을 보내 데이터를 화면에 보여주는 과정에서 서버에서 응답을 돌려줄때까지 대기하는 것을 예로 들 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function demo1() { console.log(\u0026#39;function 1\u0026#39;); demo2(); } function demo2() { console.log(\u0026#39;function 2\u0026#39;); demo3(); } function demo3() { console.log(\u0026#39;function 3\u0026#39;); } demo1(); //function 1 //function 2 //function 3   비동기 처리 모델은 병렬적 작업을 수행하는 것을 말하며 작업이 종료되지 않은 상태여도 대기하지 않고 다음 작업을 실행합니다. 예로 DOM 이벤트 헨들러, Timer 함수, ajax등이 있습니다. 아래와 같은 코드가 있을때 우리는 순차적으로 실행될 것으로 기대하지만 비동기 처리 함수 특징상 setTimeout 콜백함수는 바로 실행되지 않고 지정 대기시간을 기다리다 이벤트가 발생하면 작업 큐로 이동 후 call stack이 비어져 있을때 call stack으로 이동되어 실행됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function demo1() { console.log(\u0026#39;demo1\u0026#39;); demo2(); } function demo2() { setTimeout(function() { console.log(\u0026#39;demo2\u0026#39;); }, 0); demo3(); } function demo3() { console.log(\u0026#39;demo3\u0026#39;); } demo1(); //demo1 //demo3 //demo2   \n 비동기와 동기 모델의 차이\n 콜백 함수 비동기 처리 방식 콜백 함수란 다른 코드의 인수로 넘겨주는 실행 가능한 코드를 말합니다. 콜백 함수는 실행하는 동안에 넘겨받은 콜백을 필요에 따라 호출하고 다른 작업을 실행하는 경우도 있습니다. 쉽게 말해 다른 함수의 인자로 사용되거나 이벤트에 의해 호출되는 함수라고 볼 수 있습니다.\n이러한 콜백 함수로 특정 함수를 사용하여 특정 작업 종료 후 원하는 동작을 실행함으로써 비동기 처리 방식을 해결할 수 있습니다. 하지만 콜백 함수를 많이 사용하다보면 코드의 가독성이나 콜백에 반복으로 인해 재사용도 어렵게 됩니다. 이를 해결하기 위해 나온 방법이 Promise, Async입니다.\n1 2 3 4 5 6 7  doSomething(function(result) { doSomethingElse(result, function(newResult) { doThirdThing(newResult, function(finalResult) { console.log(\u0026#39;final result: \u0026#39; + finalResult); }, failureCallback); }, failureCallback); }, failureCallback);    콜백지옥 \u0026gt;_\n Promise? ES6 자바스크립트 비동기 처리에 사용되는 객체를 말합니다. 비동기 작업의 완료, 또는 실패를 나타내며 함수에 콜백을 전달하는 대신 첨부하는 방식의 객체로 사용합니다.\n프로미스는 Promise 생성자 함수를 인스턴스화하여 사용하며 수행할 콜백 함수를 인자로 받는데 이 콜백 함수는 resolve와 reject함수를 인자로 전달받는 특징을 가지고 있습니다.\n1 2 3 4 5 6 7 8 9  const promise1 = new Promise(function(resolve, reject) { resolve(\u0026#39;Success!\u0026#39;); }); promise1.then(function(value) { console.log(value); // expected output: \u0026#34;Success!\u0026#34; });   Promise의 상태값은 다음과 같습니다.\n   상태 의미 구현     pending 비동기 처리가 아직 수행되지 않은 상태 resolve 또는 reject 함수가 아직 호출되지 않은 상태   fulfilled 비동기 처리가 수행된 상태 (성공) resolve 함수가 호출된 상태   rejected 비동기 처리가 수행된 상태 (실패) reject 함수가 호출된 상태   settled 비동기 처리가 수행된 상태 (성공 또는 실패) resolve 또는 reject 함수가 호출된 상태    Promise 상태 변화 성공\n resolve함수 호출, fullfilled 상태 변경  실패\n reject 함수 호출, rejected 상태 변경  Promise의 에러 처리 Promise 객체의 후속 처리 메소드를 사용해 비동기 처리 결과에 대한 후속처리를 작업합니다. then()의 두번째 콜백함수로 전달되며 catch()를 사용해 에러를 처리할 수 있습니다.\n2가지의 에러처리중 권장하는 방법은 catch() 방법입니다. 이유는 then()의 첫번째 콜백 함수 내부에서 발생한 오류는 잡아내지 못하기 때문인데 다음과 같은 코드의 결과를 통해 더 쉽게 이해할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12  let demo1 = function demoFunc1() { return new Promise(function (resolve, reject) { resolve(\u0026#39;hello Korea\u0026#39;); }); } demo1().then(function (result) { console.log(result); throw new Error(\u0026#34;Error in first then()\u0026#34;); }, function (err) { console.log(\u0026#39;catch의 에러 :\u0026#39;, err); });   1 2 3 4 5 6 7 8 9 10 11 12  let demo1 = function demoFunc1() { return new Promise(function (resolve, reject) { resolve(\u0026#39;hello world\u0026#39;); });\t} demo1().then(function (result) { console.log(result); throw new Error(\u0026#34;Error in first then()\u0026#34;); }).catch(function (err) { console.log(\u0026#39;catch의 에러 :\u0026#39;, err); })    Reference  https://joshua1988.github.io/web-development/javascript/javascript-asynchronous-operation/ 인사이드 자바스크립트 https://poiemaweb.com/js-async https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise  ","description":"","id":12,"section":"posts","tags":["asynchronous","비동기"],"title":"비동기 처리 그리고 콜백함수","uri":"https://live-jh.github.io/posts/dev/asynchronous_callback_info/"},{"content":"Google Analytice UTM 대시보드 작업기 회사에서 운영중인 서비스의 사용자 통계를 분석하고자 UTM 작업과 대시보드 추가 작업을 진행해야 한다는 말에 재밌어 보여 작업을 진행하며 메모했던 내용을 되짚어 보기 위해 요약 정리한 글입니다. GA에 대한 정보가 전혀 없이 맨 바닥에 학습하며 작업하다보니 용어가 중점적일 수도 있습니다.\n개요  GA란? UTM Parameter 획득 목표 설정 기획 및 작업  GA란? 구글에서 무료로 제공하는 웹 분석 서비스를 말합니다. GA를 몰랐을땐 아무런 감정이 없었지만 시스템을 이해하고 나니 매우 대단한 서비스라 생각이 들었습니다. 막강한 기술을 제공하는데 비용은 전부 무료기 때문이죠. GA는 다양한 목표를 설정하여 획득에 대한 보고서를 확인할 수 있으며, 전자상거래 기능, 이벤트 설정등 무수한 기능을 제공하며 사용자들의 히스토리를 확인할 수 있습니다. (마케팅적으로 매우 도움이 많이 되겠죠?)\n개인적으로 단점이라 생각되는 부분은 너무 기능이 많다보니 이것 조차 프레임워크처럼 따로 학습이 필요하다는 점이었습니다. GA만의 용어, 기능이 정해져 있다 보니 커스터마이징을 하려 해도 어느 부분을 어떻게 설정해야 적용이 되는지 가이드를 보지 않고서는 쉽게 사용할 수 없었습니다. 물론 가이드도 친절하게 나와있는 편이지만 개인적으로 이 또한 많이 어려웠습니다\u0026hellip; ㅠㅜ\n 업무 시작 후 내 속마음\n UTM Parameter 쉽게 말해 광고 URL에 적용할 맞춤 매개변수를 생성하는 것을 말합니다. 보통 웹사이트를 운영하며 광고나 마케팅에 페이지 링크를 사용합니다. 이때 사용하는 링크에 맞춤 캠페인 파라미터를 추가하여 GA를 통해 트레픽을 식별하는 기능을 합니다. 사용하는 파라미터는 아래와 같습니다.\n   매개변수 항목 내용     매체 (UTM_MEDIUM) 필수 - 이메일, 디스플레이, 검색과 같은 정보\n- How (어떻게) 방문자가 사이트에 유입되었는지?\n- ex) cpc(클릭 당 비용), display, social, email   소스\n(UTM_SOURCE) 필수 - 검색엔진, 사이트 이름 등 소스에 대한 정보\n- Who(누가) 방문자를 유입시켰는가?\n- ex) google, naver, facebook   캠페인명\n(UTM_campaign) 필수 - 제품, 프로모션 코드, 슬로건\n- for what(무엇 때문에) 사이트를 방문하였는지?\n- ex) utm_campagin = spring_sale   키워드\n(UTM_TERM) 선택 - 검색광고 키워드\n- ex) winter + sale, free + coupon, online + educate   캠페인 콘텐츠\n(UTM_CONTENT) 선택 - 광고 콘텐츠, 광고 위치별 태깅에 사용 가능    획득 웹사이트에 접속하는 사용자들이 어떤 채널 경로를 통해 방문했는지에 대한 정보를 보여주는 것을 말합니다. 채널간 비교분석을 할 수 있으며 채널 개념은 referral, direct, paid search, organic search, social등이 있습니다.\nreferral\n 링크를 통한 유입 (블로그 포스팅에 걸린 링크로 접속) 링크 소스 노출 ex) GA내에 배너광고를 통해 들어온 것이라고 태깅이 존재하지 않으면 referral로 간주  direct\n 즐겨찾기 및 주소창에 직접 url을 입력하여 접근하는 방법 입력한 url 확인 가능 ex) 크롬에서 보다가 IE 환경에서 결제 요청시  paid search\n GA내에 유료 검색 광고로 태깅하여 명시한 링크를 타고 유입 ex) 네이버 키워드광고를 진행중일때 어떤 키워드를 통해 유입된지 확인 가능  organic search\n 검색사이트에서 검색어를 입력하여 유입 어떤 키워드를 검색했는지 확인 가능  social\n sns를 통한 유입 링크를 타고 들어온다는 점에서 referral과 큰 차이는 없음  display\n 배너광고로 유입 링크가 배너광고임을 명시하면 디스플레이 카테고리가 생성 referral 설명시 언급했던 것처럼 링크에 태깅이 되어있지 않으면 해당 카테고리(display)는 생성되지 않음  GA에서 자동 추적 항목  organic direct referral Google ads  자동추적하지 않는 항목  Paid search display social  목표 설정 목표 설정은 비지니스 성공에 중요한 이벤트 및 활동이 완료되는 것을 말합니다. 웹사이트 기능 및 유형에 따라 장바구니 담기, 삭제, 구매 완료, 환불 요청, 회원가입 등등으로 나누어질 수 있습니다. 즉 사이트를 운영하는 입장에서 사용자에게 기대하는 행위를 설정하는 것을 말합니다. 주요 항목은 아래와 같습니다.\n 도착(주문, 회원가입, 강의페이지 도착) 시간(세션 시간 측정) 세션당 페이지수(세션당 페이지수, 즉 페이지 별 조회 수) 이벤트(자료 다운, 동영상 재생, 광고 클릭)  기획 및 작업 후 느낀점 CMS에 필요한 기능은 크게 3가지였습니다. UTM Parameter를 생성하는 페이지와 리스트 페이지, 그리고 필요한 속성들을 조합한 GA 보고서를 API를 이용해 우리 서버측 데이터와 함께 볼 수 있는 페이지까지 총 3가지 추가 작업이 필요했습니다.\n작업을 하기 전 GA와 UTM에 대해 학습하는 시간이 필요했고 아무것도 모르다보니 GTM까지 넘어가 학습하는 바람에 조금 일정이 지연 되기도 하였습니다. GTM은 간단히 설명하자면 구글 태그매니저라고 스크립트를 통해 다양한 추적 이벤트를 활용하여 목표 설정 및 획득 그리고 전자상거래까지 추적할 수 있는 기능을 말합니다. 학습 후 해야 할 일은 크게 4가지였고 항목은 다음과 같습니다.\n 우리가 필요한 사용자 활동 속성 설정 GA 보고서에 추적이 가능하도록 서버 작업 (GA 헤더 코드 추가 및 http protocol 요청) GA 보고서 확인 작업 및 테스트 CMS에 GA API 기능 추가  작업은 순서대로 진행하였고 가장 크게 어려웠던 점은 GA에 대한 이해와 API 적용 부분이었습니다.\n서버작업은 CTO님이 도와주셔서 쉽게 끝났지만 기획부터 학습시간을 포함해 약 3주정도 걸렸던 것 같습니다. 작업이 끝난 후 아직까지 큰 시야를 보지 못하는 점때문인지 지저분한 코드가 많아 수정사항도 조금 있었습니다. 현재 업무에 적용할 코딩 컨벤션을 만들어 나가는 중인데 이를 통해 조금 개선이 되지 않을까 기대를 해봅니다.\n 나는 언제쯤 스파게티같은 코드를 벗어날 수 있을까? ㅠ\n 이번 업무를 하기 전에 사용자의 통계를 확인하여 비지니스에 접목할 수 있다는 점만으로도 충분히 도전해볼만한 가치가 있다고 생각했습니다. GA라는 것도 알게 되었고 무엇보다 작지만 해보지 않은 것에 대한 시도라 더욱 큰 보람과 성취감을 느낄 수 있었습니다. 많이 부족했고 생각보다 더디게 진행되었던 점은 단점으로 꼽을 수 있지만 마무리했다는 점은 긍정적이라 생각합니다. 추후 다른 서비스나 개인 프로젝트에도 손쉽게 적용할 수 있을 테니 매우 만족스러웠던 경험이었습니다.\n","description":"","id":13,"section":"posts","tags":["utm","ga"],"title":"GA UTM 보고서 작업 정리","uri":"https://live-jh.github.io/posts/dev/ga_utm_info/"},{"content":"모듈패턴 및 JSON? JSON이란? GET HTTP 요청을 사용하여 서버에서 JSON으로 인코딩 된 데이터를 불러오는 기능을 말합니다.\nJSON은 문자열 형태지만javascript는 data를 access하기위해 JSON 객체로 변환합니다.\n javascript는 JSON 전역객체를 통해 문자열과 상호변환을 지원 !!!\n   url : 요청을 보내는 URL 문자열\n  data : 요청과 함께 서버에 전송되는 객체\n  success : 요청이 성공시 실행되는 콜백 함수\n​\n  모듈 패턴 Java클래스처럼 JavaScript를 이용해 메소드를 가지는 객체를 구성하는 것을 말합니다.\n즉시 실행함수는 함수내부에 필요한 메소드를 구성하여 객체를 구성하는 방법을 말하며 자바스크립트의 즉시 실행함수는 첫번째 ( ) 안에 함수를 선언하고 바깥쪽 ( )에서 실행합니다.\n예제 1 2 3 4  var replyService = (function(){ return {name : \u0026#34;AAA\u0026#34;}; })();   위에 코드를 가진 js파일을 작성 후 보여줄 jsp 파일내에 자바스크립트 파일 경로를 추가합니다.\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/resources/js/reply.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\nview(jsp) 파일에 아래와 같이 자바스크립트를 작성합니다\n1 2 3 4 5 6  \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; $(document).ready(function(){ console.log(replyService); }); \u0026lt;/script\u0026gt;   이후 서버를 가동시키고 /board/get?bno=xxx 경로를 브라우저에 입력하면 아래 사진과 같이 개발자도구에서 확인이 가능합니다.\n즉시 실행 함수 함수 리터럴을 괄호 () 로 둘러싼 후 다음 () 를 추가한다. 두번째 괄호에서 메소드가 실행되며 안에 인자를 넘길 수 있습니다.\n즉시 실행함수의 경우 함수를 다시 호출할 수 없어 최초 한 번의 실행만을 필요로 하는 초기화 코드 부분에 사용합니다.\nJQuery에서 즉시 실행 함수를 사용한 이유? 자바스크립트는 변수의 유효 범위 특성을 가지고 있기 때문입니다.\n자바스크립트는 변수를 선언시 전역 유효범위를 가지게 되지만 함수 내에 정의된 매개변수와 변수는 내부에서만 유효할 뿐 함수 밖에서는 유효하지 않습니다. 이를 통해 함수 외부의 코드에서 내부의 변수에 접근하는 것이 불가능하다는 것을 알 수 있습니다.\n라이브러리 코드를 즉시 실행 함수 내부에 정의를 한다면 라이브러리 내에 변수들은 함수 외부에서 접근할 수 없기때문에 실행 함수 내에 라이브러리 코드를 추가해도 전역 네임스페이스를 건들지 않아 충돌 문제를 방지할 수 있습니다.\n모듈 패턴의 절차 네임스페이스 설정\n1 2 3 4 5 6  replyService.add({reply : \u0026#34;JS Test\u0026#34;, replyer : \u0026#34;tester\u0026#34;, bno : bnoValue}, function(result) { alert(\u0026#34;Result : \u0026#34; + result); } );   모듈 정의\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  var replyService = (function(){ //댓글 추가 \tfunction add(reply, callback, error){ console.log(\u0026#34;add reply!!!!!!!!\u0026#34;); $.ajax({ type : \u0026#39;post\u0026#39;, url : \u0026#39;/replies/new\u0026#39;, data : JSON.stringify(reply), contentType : \u0026#34;application/json; charset=utf-8\u0026#34;, success : function(result, status, xhr) { if(callback) { callback(result); } }, error : function(xhr, status, er) { if(error) { error(er); } } }) } return { add : add }; })();   xhr?  XMLHttpRequest\n자바스크립트 객체로 서버로부터 다양한 리소스를 가져오는 요청을 만들어주는 기능\n Reference  캡틴판교님 - 객체 생성패턴 인사이드 자바스크립트  ","description":"","id":14,"section":"posts","tags":["modulePattern"],"title":"모듈 패턴과 JSON 간단 정리","uri":"https://live-jh.github.io/posts/dev/module_pattern_info/"},{"content":"Vue Template 기초 정리  doit! vue.js 입문 책을 보며 학습한 내용을 간략히 정리하였습니다.\n Vue Template? HTML, CSS등 마크업 속성과 뷰 인스턴스에서 정의한 데이터 및 로직을 연결해 사용자가 브라우저를 통해 볼 수 있는 HTML 형태로 변환해주는 것을 말합니다. 템플릿 속성은 크게 2가지로 하나는 ES5에 vue template 속성을 활용하는 방법과 다른 하나는 싱글 파일 컴포넌트 체계의 template 코드를 활용하는 방법입니다.\nVue Template 속성 및 문법  데이터 바인딩 디렉티브 이벤트 처리 자바스크립트 표현식 고급 템플릿  1. 데이터 바인딩 HTML 화면 요소를 뷰 인스턴스의 데이터와 연결시키는 것으로 {{ }} 문법과 v-bind  속성을 가지고 있습니다.\n1-1. {{ }} 콧수염 괄호  HTML 태그에 뷰 인스턴스의 데이터를 연결하는 기본 텍스트 삽입 방법  1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- v-once : 뷰 데이터가 변경되어도 바꾸고 싶지 않을때 const 호이스팅 개념--\u0026gt; {{ message }} \u0026lt;/div\u0026gt;   1 2 3 4 5 6  new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue!\u0026#39; } });   1-2. v-bind  아이디, 클래스, 스타일등의 HTML 속성값에 뷰 데이터 값을 연결할 때 사용하는 방식 HTML 속성 또는 props 속성에 접두사 접근  1 2 3 4 5 6  \u0026lt;div id=\u0026#34;app\u0026#34; v-once\u0026gt; \u0026lt;!-- v-bind 생략 가능 --\u0026gt; \u0026lt;p :id = \u0026#34;idA\u0026#34;\u0026gt;아이디 바인딩\u0026lt;/p\u0026gt; \u0026lt;p v-bind:class = \u0026#34;classA\u0026#34;\u0026gt;클래스 바인딩\u0026lt;/p\u0026gt; \u0026lt;p v-bind:style = \u0026#34;styleA\u0026#34;\u0026gt;스타일 바인딩\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8  new Vue({ el: \u0026#39;#app\u0026#39;, data: { idA : 100, classA : \u0026#39;container\u0026#39;, styleA : \u0026#39;color : #008080\u0026#39; } });    v-bind를 생략할 수 있지만 HTML 문법과 구분 및 협업에 있어서 사용하는 것을 권장\n 2. 자바스크립트 표현식 {{ }} 안에 자바스크립트 표현식을 사용할 수 있습니다.\n1 2 3 4 5  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ message + \u0026#39; !!!\u0026#39;}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6  new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue\u0026#39; } });   하지만 자바스크립트 표현식은 선언과 분기처리는 할 수 없으며 복잡한 함수연산이나 접근은 뷰 인스턴스에서 처리하는걸 권장합니다.\n1 2 3 4 5 6 7 8 9 10  \u0026lt;div id=\u0026#34;app\u0026#34; v-once\u0026gt; \u0026lt;!-- 선언 불가 --\u0026gt; \u0026lt;p\u0026gt;{{ let appID = \u0026#39;10\u0026#39;; }}\u0026lt;/p\u0026gt; \u0026lt;!-- 분기 불가 --\u0026gt; \u0026lt;p\u0026gt;{{ if(appId) { return \u0026#39;100\u0026#39;; } }}\u0026lt;/p\u0026gt; \u0026lt;!-- 연산 x --\u0026gt; \u0026lt;p\u0026gt;{{ message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)}}\u0026lt;/p\u0026gt; \u0026lt;!-- 사용 가능 --\u0026gt; \u0026lt;p\u0026gt;{{ reverseMessage }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  new Vue({ el: \u0026#39;#app\u0026#39;, data: { message : \u0026#39;Hello Vue\u0026#39; }, computed : { reverseMessage : function() { return this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } });   이렇게 HTML엔 결과값만 나타내고 데이터 연산을 인스턴스내에서 처리하는 방법은 화면단의 코드 가독성을 높일 수 있으며 UI의 구조를 쉽게 파악할 수 있습니다.\n3. 디렉티브 HTML 태그 안에 v 접두사를 가지는 모든 속성을 말합니다. v-bind 속성 또한 디렉티브에 해당하며 화면의 요소를 더 쉽게 다루기 위해 사용하는 기능을 뜻합니다. (데이터 변경시 요소들이 반응하여 변경된 값에 따라 갱신)\n3-1. 디렉티브의 주요 종류    디렉티브명 기능 설명     v-if 지정된 vue 데이터의 true, false 여부에 따라 html 태그 표시   v-for 지정한 vue 데이터 개수만큼 html 반복   v-show v-if와 비슷한 개념으로 데이터의 진위여부에 따라 html 태그 표시 ( v-show는 css 효과만 display : none 옵션을 주어 화면상 노출 x)   v-bind html태그의 기본 속성과 뷰 데이터 속성을 연결   v-on 화면 요소의 이벤트 감지 후 처리시 사용 (ex = v-on : click)   v-model form에서 주로 사용되는 속성 form에 입력한 값을 뷰 인스턴스의 데이터와 동기화하여 입력한 값을 서버에 보내거나 watch등 고급속성을 이용해 로직 수행 가능(input,select,textarea)    1 2 3 4 5 6 7 8 9  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;a v-if=\u0026#34;flag\u0026#34;\u0026gt;Do it Vue.js!\u0026lt;/a\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;system in systems\u0026#34;\u0026gt;{{ system }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p v-show=\u0026#39;flag\u0026#39;\u0026gt;Do it Vue.js!\u0026lt;/p\u0026gt; \u0026lt;h5 v-bind:id=\u0026#34;uid\u0026#34;\u0026gt;뷰 입문\u0026lt;/h5\u0026gt; \u0026lt;button v-on:click=\u0026#34;popAlert\u0026#34;\u0026gt;경고 버튼\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13  new Vue({ el: \u0026#39;#app\u0026#39;, data: { flag : false, systems : [\u0026#39;android\u0026#39;, \u0026#39;ios\u0026#39;, \u0026#39;window\u0026#39;, \u0026#39;mac\u0026#39;], uid : 100 }, methods: { popAlert : function() { return alert(\u0026#34;경고창\u0026#34;); } } });   위와 같이 v-if 의 경우 html 코드태그 자체가 보이지 않지만 v-show 디렉티브의 경우 css 속성을 통해 display:none으로 변경되는 것을 확인할 수 있습니다.\n4. 이벤트처리 클릭, 키보드 입력과 같은 이벤트 처리를 말하며 v-on, methods 속성등을 활용하여 사용합니다.\n인자를 넘겨주어 그것을 활용할 수 있으며, event를 인자로 정의했을때는 해당 돔 요소의 이벤트 객체에 접근이 가능합니다.\n1 2 3 4 5 6 7 8 9 10 11  methods: { //\u0026lt;button v-on:click=\u0026#34;popAlert(10)\u0026#34;\u0026gt;경고 버튼\u0026lt;/button\u0026gt;  // popAlert : function(num) {  //\tresult : 10 경고창 확인  // return alert(num + \u0026#34; 경고창 확인\u0026#34;);  // }  //마우스 이벤트 객체 확인  popAlert : function(e) { return console.log(e); } }   5. 고급 템플릿 데이터 바인딩, 디렉티브와 같은 문법과 함께 사용하며 computed, watch등의 속성을 사용합니다.\n5-1. computed 데이터를 가공 및 연산 작업은 뷰 인스턴스에서 처리하는데 이러한 연산을 정의하는 영역을 말합니다.\n아래 예제와 같이 적용시킬 수 있으며 data 속성의 값이 변화할 때 전체 값을 다시 계산하고 동일한 연산을 반복하지 않기 위해 캐싱(연산의 결과값 저장 후 필요할 때 처리)의 기능을 합니다.\n1 2 3 4 5 6 7 8 9 10 11  new Vue({ el: \u0026#39;#app\u0026#39;, data: { message : \u0026#39;Hello Vue\u0026#39; }, computed : { reverseMessage : function() { return this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } });   reverseMessage 속성을 사용하여 이미 연산처리 되어 있는 값을 필요한 부분마다 사용할 수 있으며 화면에 결과만 표시하게 됩니다.\n이는 method 와 비슷한 개념이지만 실질적으로 computed 와 달리 method 는 속성을 호출할 때만 로직이 수행되는 차이를 가지고 있어 능동적 형태, 수동적 형태의 차이가 있습니다. 이를 통해 알 수 있는 것은 복잡한 연산이 많은 화면에서는 computed를 사용하는 것이 더 효율적이란 점입니다.\n5-2. watch 데이터 변동을 인식해 자동적으로 특정 로직을 수행하는 것을 말합니다. computed는 작은 로직에 유용한 반면 watch 속성은 상대적으로 시간이 더 소요되는 비동기 처리에 적합한 로직입니다.\n1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  new Vue({ el: \u0026#39;#app\u0026#39;, data: { message : \u0026#39;Hello Vue\u0026#39; }, watch : { message : function(data) { console.log(\u0026#34;message changed : \u0026#34;, data); } } });   input 태그에 입력한 값에 따라 console.log 에 찍히는 값이 변화되는 것을 확인할 수 있습니다.\nReference  doit vue.js 입문  ","description":"","id":15,"section":"posts","tags":["vue"],"title":"vue template 기초 정리","uri":"https://live-jh.github.io/posts/dev/vue_info/"},{"content":"Docker  도커를 사용하며 필요하고 부족했던 부분을 정리한 내용입니다.\n Docker? 컨테이너 기반의 오픈소스 가상화 플랫폼, 다양한 프로그램, 실행환경을 컨테이너 단위로 추상화하여 동일한 인터페이스로 프로그램의 배포 및 관리를 단순화 시켜주는 기능을 합니다.\n백엔드프로그램, DB서버, 메세지 큐 등 어떤 프로그램도 컨테이너로 추상화가 가능하고 aws, azure, google cloud등 실행 가능합니다.\n컨테이너와 VM의 차이 컨테이너 다른 컨테이너들과 호스트 os 자원 커널을 공유해서 사용함, 별개의 프로세스로 독립적인 환경\nVM 하이퍼바이저를 통해 호스트 os에 접속, VM은 application이 필요한 리소스보다 더 많은 것을 제공하여 효율적이지 못함\nImage 이미지는 실행 가능한 패키지(app이 구동할때 필요한 모든 것 runtime, 라이브러리, 환경변수, 설정파일등)를 말합니다. 격리된 공간에 프로세스가 동작하며 가상화 기술의 하나로 기존의 가상화와는 조금 차이가 있습니다.\n기존 가상화  VMware, VirtualBox 가상머신 호스트 OS위에 게스트 OS 전체를 가상화 방식, 다중으로 os를 가상화 할 수 있고 사용법이 간편했지만 무겁고 느려 운영환경에선 부적합  현재 가상화  CPU의 가상화기술(HVM), KVM 반가상화(Xen) -\u0026gt; 이들은 게스트 os가 필요하지만 전체 os를 가상화 하는 방식이 아님, 호스트형 가상화 방식에 비해 효율적 하지만 반가상화나 전가상화는 성능에 한계가 있어 개선하기 위해 프로세스 격리하는 방식 등장 리눅스에서 이 방식을 리눅스 컨테이너라 하고 가볍고 빠름 cpu나 메모리는 프로세스가 필요한 만큼만 추가 사용  또한 도커이미지는 컨테이너를 실행하기 위한 모든 정보를 갖고 있기에 용량이 수백메가에 이르는데 이는 기존 이미지에 추가할 때 마다 수백메가를 받을때면 비효율적이기 때문에 레이어라는 개념을 사용합니다.\n이는 여러개의 레이어를 하나의 파일시스템으로 사용하는 구조인데 이미지는 여러개 읽기전용으로 구성되고 파일이 추가 및 수정되면 새로운 레이어가 생성되어 기존 레이어를 제외한 변경되거나 추가된 부분만 다운받아 사용할 수 있다.\nContainer 컨테이너는 이미지를 실행한 인스턴스같은 개념입니다. 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것으로 상태값을 가지지 않고 불변하는 특징을 가지고 있습니다.\n컨테이너 자체는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값들은 컨테이너에 저장이 되는 구조이며, 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너 상태가 바뀌거나 삭제되더라도 이미지는 변하지 않고 그대로 유지됩니다.\n하나의 서버에 여러개 컨테이너 실행시 독립적으로 실행되어 가벼운 VM을 사용하는 느낌이며 실행중인 컨테이너에 접속하여 명령을 할 수 있고 사용자 추가, 여러개 프로세스를 백그라운드로 실행할 수도 있고 호스트의 특정포트와 연결하거나 호스트의 특정 디렉토리를 내부 디렉토리마냥 사용도 가능합니다.\nDocker Hub 도커는 생성한 이미지를 서버에 배포할때 도커레지스트리란 저장소를 사용합니다. git과 비슷하게 명령어를 사용하여 push, pull을 활용하여 공유할 수 있습니다. 도커 허브는 이러한 이미지를 저장하는 저장소로 이미지를 공유할 수 서비스를 뜻합니다.\n아래순서는 터미널 환경에서 진행합니다.\n docker에 로그인 -\u0026gt; docker login 공유할 이미지 태그달기 -\u0026gt; docker tag image명 repository:tag(버전 혹은 태그) publish 수행(이미지 게시) -\u0026gt; docker push 사용자명/repository:tag(버전 혹은 태그)  dockHub에 업로드   업로드된 이미지를 로컬에 구성하기 -\u0026gt; docker run -p 4000:80 사용자명/repository:tag  Docker Compose yaml 파일로 도커컨테이너가 프로덕션환경에서 어떤방식으로 동작할 수 있는지 정의하는 파일\nDocker Service 분산 응용프로그램에서는 각기 다른 부분을 다 서비스라고 부릅니다. 예를 들어 유투브내에는 데이터베이스에 비디오 데이터를 저장하는 서비스, 사용자가 업로드한 비디오를 인코딩하는 서비스, 프론트엔드영역에 대한 서비스등이 이를 뜻합니다.\n서비스는 실제 환경에서 사용하는 컨테이너라고 생각하면 됩니다. 서비스는 오직 하나의 이미지만 실행하며 이를 쳬계화하기 위해선 이미지를 실행하는 방법등을 정의할 수 있는데 이는 도커 플랫폼내에선 docker-compose.yml 에 작성할 수 있다.\nDockerfile 이미지를 만들때 Dockerfile이라는 파일에 자체 DSL언어를 사용하여 이미지 생성 과정을 작성하여 실행합니다. (자동화 sh 파일 생성하여 관리하는 것과 같은 원리)\n컨테이너안에 있는 환경들을 어떻게 구성되어야 하는지 정의하는 기능을 하며 port, volume, directory등 한번 등록 후 빌드시 어떤 환경에서든 동일하게 동작하게 됩니다. (도커의 특징 기능)\nDockerfile 명령어 FROM parent image로 사용하고자 하는 것 정의(기본 베이스 이미지 정의)\nFROM \u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; FROM ubuntu:18.04 WORKDIR 작업(RUN,ADD,COPY)이 이뤄질 디렉토리 지정, 같은 디렉토리에 계속 작업할 환경에서 사용\nWORKDIR /path COPY 파일, 디렉토리를 이미지로 복사, 디렉토리를 지정해주지 않는다면 자동으로 생성\nCOPY ./usr/local/ ADD COPY와 비슷한 개념이지만 현재 디렉토리의 내용을 해당 경로밑에 복사, 경로에 URL입력 가능하며 압축파일이 있다면 자동 압축해제\nADD ./usr/local/ RUN 필요로 하는 패키지를 정의하여 설치(실행 및 설치)\nRUN [\u0026quot;app\u0026quot;,\u0026quot;param\u0026quot;] EXPOSE 컨테이너 밖에 요청을 기다리는 호스트에서 사용할 포트 지정\nEXPOSE \u0026lt;port\u0026gt; ENV 컨테이너에서 사용할 환경변수 설정 Key:value\nENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; CMD 도커 컨테이너가 실행되었을때 실행하는 명령어 지정, CMD가 여러개일때 가장 마지막 커맨드라인의 명령만 실행. 여러개의 프로그램을 실행할 때는 쉘스크립트 파일을 작성하여 데몬으로 실행.\nCMD [\u0026quot;executable\u0026quot;,\u0026quot;param\u0026quot;] VOLUME 컨테이너 외부에 파일시스템을 마운트할 때 사용. 지정하지 않아도 마운트가 가능하지만 기본적으로 지정하는 것을 권장\nVOLUME [\u0026quot;/data\u0026quot;] \nDocker Server  도커를 실행하는 데몬(로컬서버, 데스크탑, 가상화, 클라우드등) 이미지를 담을 볼륨이 필요하고 해당 이미지는 내부 or 외부의 repository로 사용 서버는 운영체제가 동작하고 운영체제엔 컨테이너 서비스를 제공 docker daemon이 동작해야 가능  Docker 명령어 도커 정보 docker info 도커 버전 docker version 컨테이너 목록 확인하기 docker ps [options] options = -a, --all 컨테이너 중지 docker stop [options] container [container..] docker stop ${TENSORFLOW_CONTAINER_ID} 컨테이너 삭제 docker rm [OPTIONS] CONTAINER [CONTAINER...] docker rm ${UBUNTU_CONTAINER_ID} ${TENSORFLOW_CONTAINER_ID} 도커 이미지 목록 docker images 이미지주소, 태그, id, 생성시점, 용량등 이미지 다운 docker pull [OPTIONS] NAME[:TAG|@DIGEST] docker pull ubuntu \n그외 옵션    옵션 설명     -d detached mode 흔히 말하는 백그라운드 모드(터미널에 다른 명령어 수행가능)   -p 호스트와 컨테이너의 포트를 연결 (포워딩)   -v 호스트와 컨테이너의 디렉토리를 연결 (마운트)   -e 컨테이너 내에서 사용할 환경변수 설정   –name 컨테이너 이름 설정   –rm 프로세스 종료시 컨테이너 자동 제거   -it -i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션   –link 컨테이너 연결 [컨테이너명:별칭]   /bin/bash bash 쉘 접속 가능    References  https://docs.docker.com/get-started/ https://rampart81.github.io/post/docker_image/ https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html https://docs.docker.com/engine/reference/builder/  ","description":"","id":16,"section":"posts","tags":["docker","도커"],"title":"신입개발자의 도커와 친해지기","uri":"https://live-jh.github.io/posts/dev/docker_base/"},{"content":" AWS을 시작하며 공부하는 내용을 정리하는 글이며 지속적으로 추가/수정 할 예정입니다.\n아직 모르는 부분이 많아 부족하지만 천천히 평소처럼 삽질하며 배우려고 합니다.\n잘못된 부분이나 추가 할 부분이 있다면 댓글 남겨주시면 감사하겠습니다 :)\n 미리 알아 두면 좋은 지식 클라우드 컴퓨팅 우리가 사용하는 서버는 크게 2가지로 온프레미스와 클라우드 방식이 있습니다.\n온프레미스는 데이터센터나 서버실에 서버를 직접 관리하는 방식으로 전통적이고 널리 사용되는 방식으로 집에 있는 pc로 작은 서버를 돌리는 경우도 온프레미스에 속합니다. 온프레미스 환경에선 서버, 네트워크장비, os, 스토리지, 솔루션, 응용프로그램등 직접 구매, 설치, 관리까지 해야해 초기 투자비용이 크고 사용량을 예측하기 힘들어 사용량이 적어도 유지비용이 발생하는 단점이 존재합니다.\n클라우드 방식은 인터넷을 통해 불특정 다수에게 서비스를 제공하는 형태로 쉽게 말해 컴퓨팅 파워, 데이터베이스, os, 스토리지, 솔루션, 애플리케이션등 필요한 리소스들을 인터넷을 통해 제공받아 사용한 만큼 비용을 지불하는 방식을 말합니다. 서비스에 따라 Infrastructure as a Service(IaaS), Platform as a Service(PaaS), Software as a Service(SaaS)로 나뉘며 대표적 Cloud Provider는 aws(Amazon Web Services), MS Azure(MicroSoft), GCP(Google cloud Platform)가 있습니다.\nAWS Amazon Web Services라 말하며 클라우드 컴퓨팅의 대표적 기업으로 컴퓨팅, 운영체제, 네트워킹, 스토리지, 응용프로그램(웹서버, 데이터베이스, CRM) 등을 지원하며 클라우드 제품 및 솔루션을 통해 유연하고 안정성을 보장하는 애플리케이션 구축 서비스를 제공합니다.\nRegion 복수개의 데이터센터의 독립적인 물리적 위치를 말하며 aws 자원은 리전 단위로 제공되고 각 리전은 개별 가용구역(AZ)으로 구성되어 있습니다. (인터넷으로 연결되어 있는 지역)\nAZ(Availability Zones) 하나의 Region 내에 공간적으로 분리된 전원을 말하며 물리적 보안, 백업 역할을 하는 안전 장치로 운영되는 데이터 센터를 의미합니다. 개별적인 AZ 사이엔 낮은 속도를 가진 서버 클러스터로 연결되어 데이터 처리를 할 수 있는 특징을 가지고 있습니다.\nIAM(Identity and Access Management) 유저를 관리하고 접근 레벨 및 권한을 제어하는 기능을 말합니다. aws 계정을 생성하면 해당 계정은 루트유저가 되며 루트유저를 통해 다른 유저를 생성할 수 있습니다. 유저를 생성했을 때 접근키(access key), 비밀키(secret key)를 부여하여(ex : 읽기 권한만 가능하도록) 이를 가지고 다양한 서비스를 이용할 수 있게 됩니다. 또한 다중 인증 기능(aws 권장)을 지원하며, 비밀번호를 수시로 변경할 수 있도록 지원합니다.\nIAM에선 루트 유저로 유저뿐만 아니라 그룹, 역할, 정책들을 추가할 수 있습니다. 하나의 그룹내에 다수의 유저를 추가하여 관리할 수 있으며 유저마다 정책 및 역할을 부여해서 각 유저별 기능을 제어할 수 있습니다.\nEC2(Elastic Compute Cloud) AWS에서 제공하는 성능, 용량을 유동적으로 사용할 수 있는 가상 서버, 즉 독립된 하나의 컴퓨터를 임대해주는 것을 말합니다.\n다양한 OS를 사용 가능하며 cpu, 메모리, 네트워크에 따른 다양한 인스턴스 타입을 지원하며 다양한 과금 옵션도 제공합니다.\nInstance AWS에서 제공하는 하나의 컴퓨터입니다.\n인스턴스 컴퓨터에 원격으로 접속하여 제어 가능하며 웹서버를 설치하거나 거대한 DB 환경을 구성할 수도 있습니다.\nAMI 임대한 컴퓨터의 운영체제를 말합니다. 인스턴스를 시작하는데 필요한 정보 데이터를 이미지로 만들어 둔 것을 의미합니다.\n(보통 아마존 리눅스 AMI 1을 많이 사용하는데 이는 국내에 자료가 리눅스 1이 더 많고 각종 AWS서비스와 상성도 좋고 독자적 레포지토리 구성으로 yum이 빠릅니다.)\nStorage 하드디스크, SSD 개념으로 서버의 용량을 말합니다. 프리티어는 30GB까지 가능\nSecurity Group(보안그룹) 내 인스턴스 접속에 대한 보안이나 제어를 설정할 수 있는 모듈을 말합니다.\nType(유형)는 네트워크 트래픽에 개발할 프로토콜을 의미합니다. (ssh - 리눅스 인스턴스, rdp - 윈도우 인스턴스용, http/https - 인터넷 트래픽이 인스턴스에 도달할 수 있도록 허용)\nSource(소스)는 인스턴스에 도달할 수 있는 트래픽을 판별하는 것을 말합니다. anywhere(위치무관)는 모든 트래픽에서 접속 가능하고 my ip 는 내 pc 혹은 집에서만 접속 가능하게 하는 옵션입니다.\nEIP(탄력적 IP) EC2는 인스턴스를 중지하고 다시 시작할 때 유동적으로 새 IP가 할당됩니다. 매번 중지하고 재시작을 하게 되면 IP를 변경해서 접속하게 되는 번거로움이 생기게 되는데 이를 고정 IP로 설정하는 것을 EIP라고 부릅니다. (EIP를 생성 후 EC2에 바로 연결하지 않으면 비용이 청구되며 사용할 인스턴스가 없을 때는 꼭 EIP까지 삭제를 해주어야 합니다.)\nRDS AWS에서 DB의 모니터링, 알람, 백업등의 구성 기능을 지원하는 관리형 서비스입니다. 클라우드 기반 관계형 DB로 설정, 패치, 백업, 프로비저닝등 잦은 운영에 필요한 작업들을 자동화하여 개발자가 더욱 개발에만 집중할 수 있도록 도와주는 역할을 합니다.\n참고  AWS 클라우드 이해하기 생활코딩 아마존 웹서비스  ","description":"","id":17,"section":"posts","tags":["aws"],"title":"aws 사용 전 미리 알아두기 좋은 용어정리","uri":"https://live-jh.github.io/posts/dev/aws_start_info/"},{"content":"Ajax란?  서버로부터 데이터를 가져와 전체 페이지를 새로 고치지 않고 일부만 로드할 수 있게 하는 기법으로 비동기식 요청을 보내는데 필요한 기술을 말합니다. 새로운 페이지가 로드 되는 방식이 아닌 기존 페이지에서 요청해 데이터만 활용하는 것을 말하며 자바스크립트를 사용해 XML을 이용한 서버와 통신방법을 의미합니다. Ajax를 사용하는 기본적인 방법은 브라우저에서 제공하는 XMLHttpRequest를 사용하는 것이 기본적이지만 jQuery를 사용하면 간단하게 구현이 가능합니다.  Ajax 장단점   장점 : 비동기식 방식으로 웹서버의 응답을 기다리지 않고 데이터를 빠르게 처리할 수 있고 페이지 리로딩이 필요없다. (실시간 검색, 검색어 자동완성)\n  단점 : 한 페이지에서 지속적으로 사용할 때 리소스가 계속 쌓여 페이지가 느려질 수도 있으며 스크립트로 이루어져 있어 디버깅이 어려울 수 있다.\n  비동기식 처리모델   페이지가 로드 되는 동안 브라우저는 먼저 서버에 데이터를 요청한다.\n  Script문을 실행한 후 페이지의 나머지를 계속 로드하며 페이지와 사용자의 상호작용을 처리하며 브라우저는 요청한 데이터를 기다리지 않는다.\n  요청한 데이터가 도착하면 이벤트가 발생하면서 지정된 함수가 호출되어 실행된다.\n  $.ajax()  type : http 요청을 서버로 전송하는 형식 지정(GET, POST) url : 데이터를 전송할 URL의 주소 설정(필수) dataType : 서버가 리턴(응답)하는 데이터 타입 설정(xml, json, html) success : 정상적으로 통신에 성공했을 때 처리할 로직의 함수 (data, status, xhr)  xhr : XMLHttpRequest 객체를 생성하는 콜백함수 status : 객체의 요청상태를 나타내는 문자열 data : 요청에 응답하는 데이터   error : 통신에 실패했을 때 처리할 로직의 함수, 지정한 dataType이 아닌 다른 형식으로 응답하면 error 콜백 data : 서버에 전송할 데이터를 key : value 형식으로 설정  JSON.stringify() 메소드는 객체를 JSON 형식의 문자열로 변환 JSON.parse() 메소드는 JSON 데이터를 가진 문자열을 객체로 변환   cache : true, false로 캐시 여부를 나타냄 async : 요청시 동기화의 여부 default는 비동기(true) contentType : 서버로 데이터를 보낼때 요청하는 데이터 타입 (기본값 : \u0026quot;application/x-www-form-urlencoded; charset=UTF-8\u0026quot;)  false로 설정시 파일 전달할때 Multipart/form-data 양식으로 전송   processData : 서버에 전달되는 데이터 형식은 queryString으로 전달되는데 DOMDocument가 아닌 데이터 처리인 파일전송시에는 false 처리 complete : 요청이 종료(성공 및 오류콜백 후)될 때 호출되는 함수 (예외처리시 finally와 같은 기능) timeout : 요청제한시간으로 요청이 제한된 시간안에 완료되지 않을시 취소 또는 error 콜백  Reference  jQuery page https://poiemaweb.com/jquery-ajax-json  ","description":"","id":18,"section":"posts","tags":["ajax"],"title":"쉽게 이해하는 ajax 기초 정리","uri":"https://live-jh.github.io/posts/dev/ajax_info/"},{"content":"Vue Router \u0026amp; http 통신  doit! vue.js 입문 책을 보며 학습한 내용을 간략히 정리하였습니다.\n Routing? 웹페이지간 이동 방법으로 현재 SPA에서 가장 많이 사용되고 있습니다. SPA는 페이지간 이동시 미리 모든 페이지를 받아놓은 후 페이지가 이동시 클라이언트 라우팅을 사용하여 화면을 갱신하는 기술을 사용한 웹 애플리케이션를 뜻합니다. 보통 과거엔 페이지의 간단한 기능 하나만 요청하더라도 화면 전체의 데이터를 서버에서 다시 받아오는 방식으로 화면의 깜빡거리는 현상이나 부드럽지 못한 현상을 경험할 수 밖에 없었지만 라우팅 사용시 화면 전환이 매끄러울뿐만 아니라 성능적 측면에도 효율적이기에 더욱 쾌적한 웹애플리케이션을 구현할 수 있습니다.\nVue Router 뷰에서 라우팅의 기능을 구현할 수 있도록 지원하는 라이브러리를 말합니다.\n뷰 라우터에서 사용하는 태그(기능)은 다음과 같습니다.\n\u0026lt;router-link to =\u0026quot;url 링크\u0026quot;\u0026gt;\n 페이지 이동 태그, 화면에 \u0026lt;a\u0026gt; 태그와 동일한 기능을 하며 link to 로 지정한 링크 URL로 이동  \u0026lt;router-link\u0026gt;\n 페이지 표시 태그, 이동한 URL에 따라 변경된 컴포넌트 및 데이터를 보여주는 태그 영역  Ex 1 2 3 4 5 6 7 8 9 10  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;뷰 라우터 샘플 1\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; \u0026lt;!-- 페이지 이동 태그 to = \u0026#34;이동할 URL 경로\u0026#34;--\u0026gt; \u0026lt;router-link to=\u0026#34;/main\u0026#34;\u0026gt;Main Component\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/login\u0026#34;\u0026gt;Login Component\u0026lt;/router-link\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!-- 변경된 URL값을 보여주는 영역--\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var Main = { template: \u0026#39;\u0026lt;div\u0026gt;main\u0026lt;/div\u0026gt;\u0026#39; }; var Login = { template: \u0026#39;\u0026lt;div\u0026gt;login\u0026lt;/div\u0026gt;\u0026#39; } //url에 각 컴포넌트 변수 지정 var routes = [ {path : \u0026#39;/main\u0026#39;, component : Main}, {path : \u0026#39;/login\u0026#39;, component : Login} ]; //뷰 라우터 var router = new VueRouter({ // mode: \u0026#39;history\u0026#39;,(해시값 제거)  routes }); //뷰 인스턴스에 라우터 추가 var app = new Vue({ router }).$mount(\u0026#39;#app\u0026#39;);   Nested Router 라우터로 페이지 이동시 2개 이상의 컴포넌트를 화면에 나타내는 것을 말합니다. 상/하위 컴포넌트 구조로 구성됩니다.\nNamed View 페이지 이동시 여러개의 컴포넌트를 화면에 동시 표시하는 라우팅을 말합니다. 주로 header, body, footer등으로 나눌 수 있으며 네스티드 라우터와 다르게 같은 레벨의 컴포넌트를 한번에 표시하는 특징을 가지고 있습니다.\nNested Router Ex 1 2 3 4  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;네스티드 라우터\u0026lt;/h1\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  var User = { template : ` \u0026lt;div\u0026gt; User component \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; ` }; //컴포넌트 등록 var UserProfile = { template : \u0026#39;\u0026lt;p\u0026gt;User Profile Component\u0026lt;/p\u0026gt;\u0026#39; }; var UserPost = { template : \u0026#39;\u0026lt;p\u0026gt;User Post Component\u0026lt;/p\u0026gt;\u0026#39; }; //네스티드 라우팅 정의영역 var routes = [ { //상위 컴포넌트  path : \u0026#39;/user\u0026#39;, component : User, //하위 컴포넌트  children : [ { path : \u0026#39;posts\u0026#39;, component : UserPost }, { path : \u0026#39;profile\u0026#39;, component : UserProfile } ] } ]; //뷰 라우터 정의 var router = new VueRouter({ routes }); //뷰 인스턴스에 라우터 추가 new Vue({ router }).$mount(\u0026#39;#app\u0026#39;);   Result (/user) Result (/user/posts) Result (/user/profile)  결과 화면을 통해 상위 컴포넌트로 등록한 User 컴포넌트를 기반으로 하위에 UserPost, UserProfile이 적용되는 것과 기본 path와 하위 path를 지정하여 URL을 통해 접근할 수 있는 부분을 확인할 수 있습니다. (하위 path는 /를 사용하지 않습니다.)\n Named View Ex 1 2 3 4 5 6 7  \u0026lt;!-- 라우팅 영역 정의--\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;특정페이지로 이동시 여러개의 컴포넌트를 동시 표시 라우팅(Named View)\u0026lt;/h1\u0026gt; \u0026lt;router-view name=\u0026#39;header\u0026#39;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view name=\u0026#39;footer\u0026#39;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  //컴포넌트 영역 정의 var body = { template : \u0026#39;\u0026lt;div\u0026gt;This is Body\u0026lt;/div\u0026gt;\u0026#39; } var header = { template : \u0026#39;\u0026lt;div\u0026gt;This is Header\u0026lt;/div\u0026gt;\u0026#39; } var footer = { template : \u0026#39;\u0026lt;div\u0026gt;This is Footer\u0026lt;/div\u0026gt;\u0026#39; } var routes = [{ //기본 path 정의  path : \u0026#34;/\u0026#34;, //각 컴포넌트들 등록(default는 name 태그가 없는 영역에 자동 지정)  // 영역 : name 태그  components : { default : body, header : header, footer : footer } }]; var router = new VueRouter({ routes }); new Vue({ router }).$mount(\u0026#39;#app\u0026#39;);   Result Named View 과정 정리  사용하고자 하는 router 태그 정의 및 name 속성 추가 script의 영역으로 넘어가 해당 컴포넌트 객체 정의(template 속성 정의) 네스티드, 네임드뷰 라우팅 정의(기본 URL 속성 정의) 뷰 라우터 정의 인스턴스 생성 후 뷰 라우터 추가  Reference  doit vue.js 입문  ","description":"","id":19,"section":"posts","tags":["vue"],"title":"vue router \u0026 http 통신 이해","uri":"https://live-jh.github.io/posts/dev/vue_router/"},{"content":"메타인지 교육과 학습에 많이 나오는 용어로 나 자신을 정확하게 판단하는 것을 말한다. 쉽게 말해 내가 아는 것은 어떤 것이며 모르는 것은 무엇인지 정확하게 구분하여 판단할 수 있는 능력을 뜻하는데 이는 결국 나 자신의 부족함을 깨닫고 개선해 나가는데 아주 중요한 요소라고 생각한다.\n대게 인간은 태어나 죽을때까지 학습을 하며 살아간다고 말한다. 뒤집기를 시작으로 넘어지고 일어서기를 반복하며 학습을 통해 배운다. 성인이 된 지금도 마찬가지다. 자그마한 일조차도 누구나 다 서툴고 실수를 하기 바쁘고 이를 통해 경험이라는게 쌓여 다음 단계로 넘어갈 수 있는 능력을 가지게 된다.\n이때 나는 메타인지라는 부분이 매우 중요하다고 생각한다.\n한 발자국이 더 큰 보폭으로 더 많이 움직이려면? 솔직히 말하면 나는 학습에 대해 능통하고 효율적이고 신속하며 정확한 타입은 아니다.\n그렇기 때문에 더욱 효율적이려면 어떤 방식을 사용해야 하는지 나보다 더 효율적인 사람은 어떠한 방법을 사용했는지에 대해 호기심이 많고 배우려는 성향이 강하다. 적어도 나는 이것 저것을 대입해서 나에게 적용시켜보고 방법이 맞지 않으면 다른 방안을 찾거나 보완점을 찾으며 더 큰 보폭으로 나아가고자 한다.\n나는 얼마전부터 시작한 블로그에 학습한 내용을 꾸준히 포스팅하고 있다. 하지만 이는 내 예상과 조금씩 다르게 흘러갔다. 하나의 글을 작성하는데 소요되는 시간이 학습에 걸린 시간보다 더 소요되는 경우도 많았고 대게 예상한 시간보다 2배씩은 걸렸던 것 같다. 포스팅에 대한 부분은 분명 내가 이해한만큼 작성했기 때문에 도움은 되었지만 투자한 시간은 그리 효율적이지 못했다고 느낀 찰나에 평소 자주 읽던 출퇴근길 개발 읽기에 아주 좋은 글이 올라왔다.\n해당 글은 실용적인 프로그래밍 공부 방법과 글쓰기에 대한 내용인데 결론은 시간을 쏟아 정리를 해도 실질적으로 더 좋은 콘텐츠들이 많아 효율적이지 못하다는 것이다. 거울을 보는듯 했다. 꾸준함을 목표로 달려왔지만 효율적인 꾸준함이었을까? 2주간의 짧은 레이스에 대한 내 대답은 아니오 다.\n처음부터 글을 잘 쓰기는 매우 힘들다. 경험을 통해 극복할 수 있지만 현재 내가 집중해야 할 우선 순위는 낮기 때문에 우선 순위가 높아지는 그때가 오면 다시 조금씩 작성하는 습관을 가지려 한다.\n실행력과 집중 그리고 판단과 용기  어떠한 일에 대해 빠른 실행력을 바탕으로 집중해보고\n그에 따른 문제점이 생길시 정확하게 판단하여 선택할 수 있는 용기\n 늘 내가 배울게 많다고 얘기하지만 정작 자기 자신은 그런 사람이 아니라 얘기하는 내 소중한 동반자가 한 말이다. 누구나 알고 있지만 하기는 쉽지 않은 부분이기 때문에 더욱 어렵게 느껴지는게 사실이다. 하지만 실행이 있기에 집중을 할 수 있고 그에 따른 문제도 발생하는 것이라 나는 실행이 가장 중요하다고 생각한다. 현재 나는 학습에 도움이 되기 위해 블로그를 운영해야지 생각을 시작으로 블로그를 운영하고 있고 과정속 문제를 발견하여 효율적인 방법에 대해 고민하고 있다.\n효율적인 방법 정리하는 습관을 통해 더 효과적인 학습을 기대했지만 시간이 많이 소요되는 탓에 이는 현재 내 상황에선 치명적 단점으로 다가왔다. 결국 더 효율적인 시간투자를 위해 포스팅에 쏟는 시간을 줄이고 학습의 진도를 나가기로 정했다. 결과물을 목표로 학습하고 추후 모르는 부분에 대해 포스팅을 하는 방식으로 할 예정이다. 이 또한 시간을 많이 소요 되지 않는 선에서 중요한 핵심 부분만 기록할 생각이다.\n다양한 분야마다 조금씩 차이는 있겠지만 내가 나아갈 개발자의 입장에서 더 나은 학습에 대한 키워드를 요약하자면 다음과 같다.\n키워드  의식적인 연습 취사선택 선택과 집중  어려운 것을 쉽게 배우는 방법  따라하며 익숙해지기  샘플코드 확보, 모르는 부분 파악   문제에 도전하기  1단계의 혼란에 대해 습득 및 해소   무엇인가 만들어보기  코드 복붙이 아닌 새로운 것에 대한 프로토 타입 만들기    오늘은 일주일정도 모은 개발 콘텐츠를 읽으며 느꼈던 생각을 조금 정리해봤다.\n나는 이제 새로운 포트폴리오 준비를 위해 그간 학습해왔던 것을 바탕으로 계획을 세워 나만의 사이클을 반복할 예정이다.\n학습을 위해 투자한 시간동안 내가 겪었던 문제점을 개선해 나가며 더 효율적인 방법으로 좋은 결과물을 내기 위해 노력해야겠다.\n","description":"","id":20,"section":"posts","tags":["메타인지"],"title":"효율적 방법과 메타인지","uri":"https://live-jh.github.io/posts/think/2019_blah_1/"},{"content":"1. 자료구조의 중요성  해당 포스팅은 누구나 자료구조와 알고리즘을 읽으며\n정리한 내용입니다.\n 배열(기초자료구조)  배열은 컴퓨터 과학의 기초 자료중 하나  자료구조는 4가지   읽기\n 자료구조 내 특정 위치를 찾는 것 혹은 특정 인덱스 값을 찾아 보는 것    검색\n 자료 구조 내 특정 값을 찾는 것, 특정 값이 있는지 혹은 특정 값의 인덱스를 찾는 것    삽입\n 자료 구조 내 슬롯을 새로 만들어 새로운 값을 추가하는 것    삭제\n 자료 구조 내 값을 제거하는 것    연산이 빠른가에 대한 측정의 기준은 얼마나 많은 연산 단계가 필요한지가 기준이 됩니다.\n시간은 연산을 실행하는 하드웨어의 성능에 따른 변수가 발생할 수 있기에 하드웨어의 조건을 동일하다 놓고 볼때\n**단계(Step)**가 결국 성능을 결정합니다. 이러한 측정의 단위를 시간 복잡도, 성능, 효율성이라 표현합니다.\n읽기 배열에서 읽기의 단계는 한단계입니다. 배열 내 특정 인덱스에 한번에 접근 하여 데이터를 확인 할 수 있기 때문입니다.\n  컴퓨터는 모든 메모리의 주소에 한번에 접근 가능\n  각 배열의 저장된 내용은 메모리의 시작 주소\n  배열의 인덱스 시작은 0\n  이러한 조건들로 인해 한번에 접근하여 데이터를 확인 가능하며 길이가 5까지인 배열에서 인덱스 3의 위치를 읽는 단계는 다음과 같습니다.\n  0부터 시작하는 인덱스의 메모리 주소를 확인\n  0부터 3까지는 3칸을 이동하면 읽기 가능\n  0의 메모리 주소인 1010에서 + 3을 하여 메모리주소 1013의 위치 확인\n  해당 위치의 데이터 값을 반환\n  검색 검색은 읽기와 다르게 특정 값을 찾는 활동입니다. 예를들어 카드를 뒤집어 놓고 찾고자 하는 카드를 찾는 것과 동일합니다.\n \u0026ldquo;Chelsea\u0026rdquo;, \u0026ldquo;Arsenal\u0026rdquo;, \u0026ldquo;Liverpool\u0026rdquo;, \u0026ldquo;Juventus\u0026rdquo;, \u0026ldquo;RealMadrid\u0026rdquo;\n라는 배열이 있다고 가정합니다.\n Liverpool을 찾는다면?\n  배열의 0번부터 하나씩 순차적으로 확인\n  한 번에 하나씩 확인 하는 것 -\u0026gt; 선형검색\n  Liverpool을 찾을때 연산은 3단계\n  이는 배열의 선형검색으로 인한 최대 단계수는 N\n Ex) RealMadrid를 찾는 단계는 5단계 == 배열의 길이 5        삽입 삽입은 어느 위치에 삽입하는 것에 따른 효율성의 차이를 보입니다.\n \u0026ldquo;Chelsea\u0026rdquo;, \u0026ldquo;Arsenal\u0026rdquo;, \u0026ldquo;Liverpool\u0026rdquo;, \u0026ldquo;Juventus\u0026rdquo;, \u0026ldquo;RealMadrid\u0026rdquo;\n라는 배열이 있다고 가정합니다.\n \u0026ldquo;AtleticoMadrid\u0026rdquo; 를 삽입하세요.\n최적 삽입\n  맨 끝에 삽입\n 1단계 End~    최악 삽입\n  맨 앞에 삽입\n  삽입을 위한 슬롯을 생성해야 합니다.\n  배열의 가장 끝인 4번 인덱스인 RealMadird는 5번 인덱스인 오른쪽으로 이동\n  빈 4번 인덱스 자리엔 3번 인덱스였던 Juventus가 이동\n  빈 3번 인덱스 자리엔 2번 인덱스였던 Liverpool이 이동.. 반복\n  Chelsea가 1번 인덱스로 이동하여 빈 공간인 0번 인덱스에 AlteticoMadrid 삽입\n  이동 5회, 삽입 1회 총 6회 (N+1)\n    삭제 삭제는 특정 인덱스의 값을 삭제하는 것이며 삽입과 마찬가지로 맨 끝에 있는 것을 삭제하면 최적이지만 중간이나 앞에 있는 부분을 삭제하면 빈 슬롯이 생겨 이동 해야 하는 경우가 생깁니다.\n \u0026ldquo;Chelsea\u0026rdquo;, \u0026ldquo;Arsenal\u0026rdquo;, \u0026ldquo;Liverpool\u0026rdquo;, \u0026ldquo;Juventus\u0026rdquo;, \u0026ldquo;RealMadrid\u0026rdquo;\n라는 배열이 있다고 가정합니다.\n \u0026ldquo;Juventus\u0026quot;를 삭제하세요.\n  Juventus 삭제\n  삭제 후 빈 3번 인덱스의 슬롯의 위치로 RealMadrid 이동\n  삭제는 한 단계지만 삭제 후 빈 슬롯이 발생시 데이터를 이동시켜야 하는 단계가 추가적으로 발생합니다.\n최적 삭제\n 삽입과 동일 (맨 끝)  최악 삭제\n  삽입과 동일 (맨 앞)\n N    집합(중복 허용 X 자료구조)  집합은 중복 데이터가 없을 때 유용\n이러한 제약은 효율성에 큰 영향\n 집합의 읽기\n  배열의 읽기와 동일\n 1단계    집합의 검색\n  배열의 검색과 동일\n 최대 N단계    집합의 삭제\n  배열의 삭제와 동일\n 최대 N단계    집합의 삽입\n  중복데이터 허용이 되지 않기에 삽입하고자 하는 데이터 값이 기존 배열 있는지 확인 후 삽입해야 합니다.\n 이는 검색이 우선시 되야 하는 제약    배열삽입의 최선삽입 1단계 -\u0026gt; 집합삽입 최선 N+1단계(검색 N + 삽입 1)\n  배열삽입의 최악삽입 N+1 -\u0026gt; 집합삽입의 최악 2N+1단계(검색 N + 이동 N + 삽입 1)\n  참고  [누구나 자료구조와 알고리즘](  ","description":"","id":21,"section":"posts","tags":["자료구조","알고리즘"],"title":"자료구조의 간단한 기초 개념","uri":"https://live-jh.github.io/posts/algorithm/data_structure_important/"},{"content":"알고리즘 알고리즘은 어떤 문제를 해결하기 위한 여러 동작들의 모임을 말합니다. 다시 말해 어떤 값을 입력받아 결과 값을 출력하는 절차를 의미합니다. 이러한 문제 해결에 필요한 조건은 다음과 같습니다.\n 입력 : 0개 이상의 입력(외부) 데이터가 존재해야 한다. 출력 : 1개 이상의 결과가 존재해야 하며 중복되지 않은 2개 이상의 결과가 있어야 한다. 유한성 : 모든 과정 및 명령은 유한한 범위에서 실행과 종료 해야한다. 효율성 : 모든 과정은 명백히 실행 가능한 범위에 있어야 한다. 명확성 : 수행과정은 명확해야 한다.  좋은 알고리즘이란? 좋은 알고리즘이란 처리 시간이 짧고, 사용 메모리가 적은 것을 말합니다. 우리는 두가지 조건을 각각 시간 복잡도, 공간 복잡도라 말합니다.\n시간 복잡도는 알고리즘을 수행하는데 평균, 최악의 경우 얼마만큼의 수행 시간이 발생하는지를 말하고 공간복잡도는 알고리즘을 수행하는데 얼마만큼의 메모리를 사용하는지를 의미합니다.\n이러한 복잡도를 표기할 때 우리는 보통 빅오 표기법을 사용해서 나타냅니다. 빅오 표기법은 알고리즘의 복잡도(빠르기)를 단순화할 때 사용되는 대표적 표기법이며 연산 횟수를 기준으로 하기 때문에 속도를 시간단위로 세지 않는 특징을 가지고 있습니다.\n빅오표기법 빅오표기법은 시간 복잡도 알고리즘에 불필요한 연산을 제거해 알고리즘 분석을 조금 더 간편하게 할 목적으로 시간 복잡도를 표기하는 방법입니다.\n O(1) \u0026lt; O(log n) \u0026lt; O(n) \u0026lt; O(n log n) \u0026lt; O(n²) \u0026lt; O(2ⁿ) \u0026lt; O(n!) \u0026lt; O(nⁿ)\n    O(log n) O(n) O(n log n) O(n²) O(n!)     이진탐색 단순탐색 퀵정렬 선택정렬 외판원문제    시간복잡도에서 가장 중요한 부분은 n의 단위입니다. 상수는 알고리즘이 소비하는 어떠한 특정 시간으로 불리는데 예를 들어 두 개의 알고리즘이 서로 다른 빅오 표기법의 시간을 가지는 조건에서는 상수는 크게 문제가 되지 않습니다.\n 단순 탐색 : 10밀리초 * n\n이진 탐색 : 1초 * log n\n 위와 같이 알고리즘의 처리속도가 존재할 때 단순히 보기엔 단순 탐색이 훨씬 더 빠르다고 생각할 수 있습니다. 하지만 40억개의 원소를 가진 리스트를 탐색한다고 가정했을때 걸리는 시간은 다음과 같습니다.\n 단순탐색 : 10밀리초 * 4,000,000,000 = 463초\n이진 탐색 : 1초 * 32 (log n) = 32초\n 데이터의 양이 많아지는 조건에서는 이진 탐색이 훨씬 빨라지는 것을 알 수 있으므로 상수는 전혀 문제가 되지 않는 것을 확인할 수 있습니다. (가끔 예외적인 경우 -\u0026gt; 퀵 정렬과 병합 정렬)\n문제 해결 단계  O(1) : 상수시간  문제를 해결하는데 한 단계 처리   O(log n) : 로그시간  문제를 해결하는데 필요한 단계들이 연산을 거듭할수록 특정 조건에 의해 감소 입력의 크기에 따라 연산 횟수가 줄어드는 케이스   O(n) : 직선시간  문제를 해결하기 위한 단계수와 입력값 n이 1:1 로 동일 Ex : 배열의 길이만큼 반복하는 케이스   O(n log n) : 선형로그  문제를 해결하기 위한 단계수가 n * log2ⁿ 만큼 가짐   n² : 2차 시간  문제를 해결하기 위한 단계수는 n의 제곱 Ex : 반복문이 두번 있는 케이스    정렬 알고리즘 비교    알고리즘 최선 평균 최악     Bubble Sort O(n) O(n²) O(n²)   Heap Sort O(n log n) O(n log n) O(n log n)   Insertion Sort O(n) O(n²) O(n²)   Merge Sort O(n log n) O(n log n) O(n log n)   Quick Sort O(n log n) O(n log n) O(n²)   Selection Sort O(n²) O(n²) O(n²)   Shell Sort O(n) O(n log n²) O(n log n²)   Smooth Sort O(n) O(n log n) O(n log n)    Reference  그림으로 개념을 이해하는 알고리즘 https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 https://opentutorials.org/course/2471/13912 https://madplay.github.io/post/time-complexity-space-complexity https://brenden.tistory.com/2 https://www.youtube.com/watch?v=Y7KTRu6-XK0 https://blog.chulgil.me/algorithm/  ","description":"","id":22,"section":"posts","tags":["빅오표기법","알고리즘"],"title":"간단히 알아보는 빅오표기법","uri":"https://live-jh.github.io/posts/algorithm/big_o_info/"},{"content":" 해당 글은 알고리즘을 학습하며 개인적으로 이해한 내용을 정리한 글입니다.\n잘못된 부분이 있다면 댓글로 알려주시면 감사하겠습니다 :)\n 이진탐색? 이진탐색은 정렬된 데이터에서 특정한 값을 찾는 알고리즘입니다.\n배열의 총 길이만큼 반복하며 배열의 중간에 있는 임의의 값(A)을 선택하여 찾고자 하는 값(B)과 비교를 하는 방법으로 B의 값이 A보다 작으면 A값 제외한 A보다 작은 쪽을 재탐색하고 B의 값이 A보다 크면 A값 제외한 A보다 큰 쪽을 재탐색하는 방식입니다.\n또한 순차 탐색에 비해 훨씬 빠른 속도를 가지고 있지만 정렬이 되어 있을 때만 사용할 수 있다는 단점을 가지고 있습니다.\n실행시간 n개의 데이터를 가진 리스트에 이진 탐색을 사용할 시 최대 log2N번의 횟수가 발생합니다.\nlog란 거듭 제곱의 반댓말로 log2 8일때 2 * 2 * 2 = 8로 총 3번의 횟수를 의미합니다.\n예제코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  # item = 찾는 데이터 # 최소값과 최대값의 인덱스를 지정한다. # 주어진 배열의 길이만큼 반복하며 중간 인덱스의 값을 guess 변수로 활용한다. # 짐작하는 guess의 값이 item값보다 작으면 최소값의 인덱스를 guess의 인덱스에 +1 해준다.(mid + 1) # 짐작하는 guess의 값이 item값보다 크면 최대값의 인덱스를 guess의 인덱스에 -1 해준다.(mid - 1) # 반복하면서 guess의 값과 item값이 일치할 때 return mid, 리스트에 없는 숫자를 입력한다면 return None def binary_search(list, item): low = 0 high = len(list) - 1 while low \u0026lt;= high: mid = (low + high) // 2 guess = list[mid] if guess == item: return mid elif guess \u0026lt; item: low = mid + 1 else: high = mid - 1 return None num_list = [1, 11, 32, 64] print(binary_search(num_list, 64)) # 3   \nReference  그림으로 개념을 이해하는 알고리즘 위키백과  ","description":"","id":23,"section":"posts","tags":["이진탐색","알고리즘"],"title":"[python] 이진탐색의 이해와 예제 코드","uri":"https://live-jh.github.io/posts/algorithm/binary_search/"},{"content":"빅오표기법 알고리즘이 얼마나 빠른지에 대한 표시방법입니다.\n연산횟수를 기준으로 하기 때문에 속도를 시간단위로 세지 않으며 빅오표기법은 최악의 경우에 대한 기준으로 합니다.\n표기법  n은 연산 횟수를 뜻합니다.\n 단순탐색  하나씩 확인 -\u0026gt; O(n)  ex) O(16) = 16    이진탐색  Log n번 확인 -\u0026gt; O(log n)  ex) O(log 16) = 4    이진탐색은 정렬된 상태에서 사용 가능합니다. 리스트에 원하는 데이터가 있으면 데이터의 위치를 반환하고 없으면 null을 반환합니다.\n 1~100 사이에 숫자를 하나를 생각합니다. 범위를 절반을 기준으로 줄여나갑니다. (100 - 50 - 25 - 13 - 7 - 4 - 2 - 1) 최대 7단계  처음부터 순차적으로 탐색하는 단순 탐색은 위와 같은 범위를 가질 때 최대 99번을 반복해야 찾을 수 있기에 효율적이지 못합니다.\nlog2N n개의 데이터를 가진 리스트에 이진 탐색을 사용할 시 최대 log2N번의 횟수가 발생합니다.\nlog란 거듭 제곱의 반댓말로 log2 8일때 2 * 2 * 2 = 3번의 횟수를 의미합니다.\n실행 시간 선형시간 계산복잡도 이론상 에서 입력의 길이 n에 대해 특정 알고리즘의 실행시간이 선형의 특징을 가지는 것을 말합니다. 예를 들어 100의 길이를 가진 원소를 단순탐색으로 자료를 확인한다면 100번의 횟수를 확인해야 하고 이때 걸리는 시간을 선형시간이라 말합니다.\n로그시간 정렬된 리스트를 이진탐색 사용시 원소의 log2N번의 횟수로 자료를 찾을 수 있습니다. log28 -\u0026gt; 3회, log232 -\u0026gt; 5회, log21024 -\u0026gt; 10회 이진탐색의 경우 로그시간으로 실행됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  private static Integer binarySearch(int[] list, int target) { int low = 0; int high = list.length - 1; while(low \u0026lt;= high) { int mid = (low + high) / 2; int guess = list[mid]; if(guess == target) { return mid; } //찾고자 하는 값이 절반 값보다 크면 mid 값에 다음 인덱스를 low로  //반대로 찾고자 하는 값이 절반 값보다 작으면 mid 위치의 바로 전 인덱스를 high로  if(guess \u0026lt; target) { low = mid + 1; } else { high = mid - 1; } } return null; }   \n알고리즘 속도   알고리즘의 속도는 시간이 아니라 연산 횟수에 의한 측정\n  알고리즘의 실행 시간은 빅오 표기법을 사용\n  배열 및 연결리스트 모든 원소의 값을 한 번에 읽어야 한다면 연결리스트, 특정한 원소만 알고 싶다면 모든 원소 주소를 다 알고 있는 배열이 유리합니다.\n원소를 가운데 삽입할 때 연결리스트는 이전 원소가 무엇을 가리키는지만 바꾸면 되고 배열은 모든 원소의 위치를 바꿔야 하기 때문에 리스트가 더 유리하고 삭제도 마찬가지로 배열에서는 한 요소를 삭제한다면 나머지 요소들을 이동해줘야하기 떄문에 리스트가 더 적합합니다.\n자료 접근 방식  임의접근  배열 (순차적이 아니라 찾고자 하는 요소로 바로 건너 읽기)  읽기 속도가 빠름     순차접근 (원소를 첫번째부터 순차적으로 하나씩 읽기)  연결리스트    선택정렬 주어진 배열을 하나씩 확인하면서 가장 작은 수를 찾아 맨 앞 값과 교체하는 정렬을 말합니다. 쉽게 말해 가장 작은 수를 선택하여 정렬하는 방식이며 가장 단순한 정렬 방법중 하나입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  private static List\u0026lt;Integer\u0026gt; mySelectionSort(List\u0026lt;Integer\u0026gt; arr) { for(int i = 0; i \u0026lt; arr.size(); i++) { int min = i; for(int j = i+1; j \u0026lt; arr.size(); j++) { if(arr.get(j) \u0026lt; arr.get(min)) { min = j; } } Collections.swap(arr, min, i); } return arr; } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; arr = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(13, 4, 3, 6, 9)); System.out.println(\u0026#34;-----선택정렬-----\u0026#34;); System.out.println(mySelectionSort(arr)); }    재귀함수 재귀함수란 자기 자신을 호출하여 작업을 수행하는 방식의 함수를 말합니다. 재귀함수는 기본단계와 재귀단계로 나누어져 있고 사용할 때는 실수로 무한반복 함수를 만들 수 있기에 종료 조건을 생성해야 합니다. 재귀 단계는 자기 자신을 호출하는 부분이고 기본 단계는 자기 자신을 호출하지 않도록 조건을 거는 부분을 말합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private static int countdown(int i) { System.out.println(i); //기본단계  if(i \u0026lt;= 1) { return 1; } else { //재귀단계  //ex) 3 * 2 * 1 =  return i * countdown(i - 1); } } public static void main(String[] args) { System.out.println(countdown(3)); }   \n스택 스택이란 오직 한 쪽 끝에서 자료를 추가 및 삭제할 수 있는 LIFO의 자료구조입니다. 가장 나중에 넣은 데이터를 가장 먼저 꺼내는 방식으로 데이터를 꺼내는 작업을 pop(삭제), 반대로 스택에 데이터를 삽입하는 작업을 push(삽입) 라고 합니다.\n호출 스택 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * @Title 호출스택 * @Description * 실행 순서에 따른 메모리와 스택의 관계를 생각하기 * 함수가 실행될때는 메모리에 변수가 할당되지만 종료 후 존재하던 변수와 함수는 메모리에서 사라진다 -\u0026gt; pop 연산 */ public class Greeting { private static void bye () { System.out.println(\u0026#34;ok bye!\u0026#34;); } private static void greet2 (String name) { System.out.println(\u0026#34;how r u, \u0026#34; + name + \u0026#34;?\u0026#34;); } private static void greet (String name) { System.out.println(\u0026#34;hello, \u0026#34; + name + \u0026#34;!\u0026#34;); greet2(name); System.out.println(\u0026#34;getting ready to say bye..\u0026#34;); bye(); } public static void main(String[] args) { greet(\u0026#34;easy\u0026#34;); } }   \n분할정복 Divide \u0026amp; Conquer 이라고 불리며 Recursion(재귀) 기반 알고리즘입니다. 분할(문제 데이터 분할), 정복(나누어진 작은 문제를 재귀로 해결), 통합(분할된 문제의 결과를 통합하여 결론 도출) 로 구성되어 있습니다. 쉽게 말해 자신을 호출하며 연산의 단위를 줄여나가는 방식을 말합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private static int sum(int[]arr) { //가장 기본단계는 배열의 길이가 0이거나 1일때 합계를 구하는 것이므로  //0번 인덱스를 분리시키는 작업을 기본단계로 구성한다.  if(arr.length == 0) { return 0; } else { //데이터 분할(0번 인덱스 + 나머지 인덱스)  //복사할 Arrays.copyOfRang(복사할배열, 복사 시작인덱스, 복사 끝인덱스) -\u0026gt; 재귀 호출  return arr[0] + sum(Arrays.copyOfRange(arr, 1, arr.length)); } } public static void main(String[] args) { System.out.println(sum(new int [] {1,3,5,4})); }   퀵정렬 퀵정렬은 정렬 알고리즘 종류중 하나로 매우 빠른 속도를 가진 정렬 방법입니다.\n분할 정복 알고리즘중 하나로 다른 원소와의 비교만으로 정렬을 수행하는 특징을 가지고 있습니다.\n분할정복이란 어떠한 문제를 2개로 분할하여 재귀를 활용하여 각각 문제를 따로 해결한 뒤 결과를 다시 재결합 하는 것을 말합니다.\n이제 간단한 예제로 배열을 정리하기 위해 퀵 정렬을 사용해볼 텐데 정렬할 필요가 없는 정렬은 바로 비어있는 배열이나, 원소가 하나인 배열을 예로 들 수 있습니다.\n1 2 3  if(list.size() \u0026lt; 2) { return list; }   배열의 길이가 2일 경우 첫번째와 두번째 원소끼리 비교 후 첫번째 원소가 더 작은 수가 될 수 있도록 오름차순으로 교환을 해주면 됩니다.\n이후 3이상의 길이를 가진 배열은 기본 단계가 될 때까지 나눠야 합니다.\n방법은 다음과 같습니다.\n 기준 원소(pivot)를 지정 모든 원소를 기준 원소보다 작은 원소, 큰 원소로 분류 (분할)  pivot보다 작은 하위 배열, pivot보다 큰 하위 배열   하위 배열에 대해 재귀를 통해 퀵 정렬을 호출  Ex [31, 27, 6, 3]\n 0번 인덱스를 pivot으로 설정 27,6, 3, 31,  27,6, 3 분할   6, 3, 27,  6, 3 분할   3, 6,  3 분할   [3, 6, 27, 31]  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  private static List\u0026lt;Integer\u0026gt; quickSort(List\u0026lt;Integer\u0026gt; list) { if(list.size() \u0026lt; 2) { return list; } else { Integer pivot = list.get(0); List\u0026lt;Integer\u0026gt; less = list.stream().skip(1).filter(el -\u0026gt; el \u0026lt;= pivot) .collect(Collectors.toList()); List\u0026lt;Integer\u0026gt; greater = list.stream().skip(1).filter(el -\u0026gt; el \u0026gt; pivot) .collect(Collectors.toList()); return Stream.of( quickSort(less).stream(), Stream.of(pivot), quickSort(greater).stream()) .flatMap(Function.identity()).collect(Collectors.toList()); } } public static void main(String[] args) { System.out.println(quickSort(Arrays.asList(31,27,6,3))); }   \n해시 함수? 해시 함수는 데이터의 효율적 관리를 위해 임의의 길이를 가진 데이터를 고정 크기의 데이터로 매핑하는 알고리즘 함수입니다. 매핑 전 원래 데이터를 key값으로 매핑 후 데이터 값을 해시 값으로 매핑하는 과정을 해싱이라 부릅니다.\n쉽게 예를 들자면 가게의 메뉴판과 가격이 있습니다. 초기엔 모든 메뉴의 가격을 외울 수 없기에 일일이 찾아보며 계산을 해야합니다. 하지만 익숙해져 시간이 흐른 뒤 모든 메뉴별 가격을 알고 있다면 모든 항목에 대해 바로 계산이 가능하게 되며 해시 함수 자체는 O(1)의 속도를 확인할 수 있었습니다.\n또한 해시 함수 자체는 하나의 해시값보다 많은 키값을 가지고 있어 이를 대응할 때 키 값이 두개의 동일한 해시값을 가지는 경우 이를 해시 충돌 이라 표현하기도 합니다. (서로 다른 키가 같은 해시가 되는 경우)\n해시 함수 특징  같은 key값의 이름에 대해서는 항상 같은 인덱스를 할당합니다.  Ex : avocado -\u0026gt; 1 (반복해도 계속) 1    해시 테이블 해시 테이블은 컴퓨팅에 키 값에 매핑할 수 있는 구조인 연관 배열을 추가하는 자료 구조 알고리즘을 말합니다. 거의 모든 프로그래밍 언어들이 해시테이블을 지원합니다.\n해시 함수는 다음의 명령을 지원합니다.\n 키가 주어졌을 때 연관되는 값을 얻어내는 명령 키와 새로운 값이 주어졌을 때 기존 키와 관련 있는 값을 새롭게 교체하는 명령 키가 주어졌을 때 관련된 값을 제거하는 명령 키와 값이 주어졌을때 연관배열에 두 값을 저장하는 명령(키, 값)  해시 테이블의 장점  관계를 모방할 수 있다. 중복을 막을 수 있다. 서버에게 작업을 시키지 않고 자료 캐싱이 가능하다.  Reference  그림으로 개념을 이해하는 알고리즘 http://iloveulhj.github.io/posts/java/java-stream-api.html https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html https://jeong-pro.tistory.com/165 위키백과 https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o https://www.youtube.com/watch?v=xls6jEZNA7Y  https://dbehdrhs.tistory.com/70 https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98  ","description":"","id":24,"section":"posts","tags":["algorithm","알고리즘"],"title":"알고리즘을 공부 하기전 알면 좋은 기초 개념 정리","uri":"https://live-jh.github.io/posts/algorithm/algorithm_info/"},{"content":"기록하고 싶은 이미지를 업로드합니다. 📷\n","description":"","id":25,"section":"","tags":null,"title":"Gallery","uri":"https://live-jh.github.io/gallery/"},{"content":"\n\n안녕하세요. 지구를 사랑하는 개발자 이지환입니다.\n저는 지속이란 단어를 좋아하고 배움과 경험하는 것에 대해 소중함을 느끼며 협업하기 좋은 서버개발자로 성장하기 위해 노력합니다.\n평소 축구와 여행, 그리고 사람들과 소통하기를 좋아합니다.\nProfile  이지환 (live-jh)  Experience  Tendom - Back-End Developer (2019.07 ~ )  Skills  Python \u0026amp; Django Javascript React MySQL \u0026amp; PostgreSQL AWS  Contact  Email : livejh7129@gmail.com Github : https://github.com/live-jh/  ","description":"","id":26,"section":"","tags":null,"title":"about me","uri":"https://live-jh.github.io/about/"},{"content":"개발자의 첫 걸음 남들이 하지 않는 것만 골라 경험했던 20대의 끝자락에 문득 나만의 기술을 가지고 앞으로 남은 인생을 살아가야겠다는 생각을 시작으로 고민하던 중 주변 지인들을 통해 개발자라는 직무에 관심을 갖게 되었습니다.\n그때 당시 무작정 직장을 관두고 기초적인 HTML 독학을 시작으로 국비지원 교육을 수료했고 이후 6개월 뒤 현재 작은 스타트업에서 백엔드 개발자의 길을 걷게 되었습니다. 입사 전 준비과정과 입사 후 현재 2개월간의 생활까지 약 1년 4개월을 정리해보고자 합니다.\n준비과정 part. 1 개발자로 커리어 전환을 마음먹고 퇴사 후 약 한 달간의 독학을 진행했습니다. 생활코딩을 보며 독학을 했었고 이해라기보다는 따라 하면서 코딩에 대한 느낌을 살짝 맛보는 정도로 시작했던것 같습니다. 국비지원 교육 기간엔 비전공자들과 함께 스터디를 운영하며 공부하였고 중간에 학위에 맞는 정보처리기능사 자격증을 취득하였습니다. 6개월간의 짧은 여정의 끝이 보일 때쯤 취업을 준비해야 할 시기가 다가왔었습니다. 그때 당시 전 SI 회사보다는 스타트업을 가고 싶었지만 고졸 비전공자의 현실의 벽은 높았고 매번 서류 탈락 결과를 마주할 수밖에 없었습니다. 이후 눈을 낮춰 SI 회사들도 지원하게 되었으며 운이 좋게 파견을 나가지 않고 사수 개발자분들도 많은 작은 SI 회사에 취업할 수 있었습니다.\n우여곡절 끝에 입사하여 수습 기간 동안 정말 좋은 팀원분들 덕분에 실무에 필요한 정말 많은 것들을 배우기 시작했고 기초가 늘 부족했던 탓에 업무에 사용하는 사소한 용어까지도 출퇴근 시간을 활용해 제 것으로 만들기 위해 노력했습니다. 하지만 학업의 욕심과 동시에 자사 서비스 회사에 대한 도전을 위해 회사와 상의 후 퇴사를 결정하게 되었고 약 2개월의 짧은 경험을 접고 다시 기약 없는 출발선에 서게 됩니다.\n준비과정 part. 2 퇴사 후 시간을 헛되게 보내고 싶지 않았기에 취업준비(포트폴리오)와 더불어 학점은행제를 통해 전문 학사를 취득할 계획을 세웠습니다. (쉽지 않겠지만 전문 학사 이후 방통대 편입하여 학사까지 취득할 계획입니다.)\n전문 학사를 위해 제일 먼저 했던 부분은 독학사 시험을 준비했던 과정이었습니다. 1년에 한번 있는 시험인데 퇴사 후 한 달 뒤가 시험날이라 개발은 손도 못 대고 집에서 수면 아니면 공부만 했던 기억이 납니다.\n약 600페이지가 넘는 분량을 책이 너덜너덜해질 때까지 보고 기출문제는 시험 보기 직전까지 5번 정도 보니 시험은 무난하게 합격할 수 있었습니다.\n 이런 정신력으로 진작에 일찍 공부했으면 조금 더 배움의 키가 자라지 않았을까..?\n 독학사 시험 준비를 하며 코드를 치는 게 덜 스트레스 받겠다 싶을 정도로 코딩을 하지 않는 것에 대해 불안함과 스트레스를 많이 받았습니다. 하지만 시험을 합격한 후 학점은행제 전공과목을 수강하며 포트폴리오를 준비하는 과정에서 시간 부족과 동시에 다양한 에러를 만나며 더 큰 스트레스와 함께 난관에 봉착하게 됩니다. 기초적인 부분부터 가이드라인이 필요하단 판단을 내린 후 해결책으로 코드로 배우는 스프링 웹 프로젝트 책을 통해 CRUD와 Ajax, 프로젝트 환경설정 및 SpringSecurity 등을 효과적으로 학습할 수 있었습니다. 그리고 학습한 내용과 프로젝트는 각각 블로그와 Github에 코드를 업로드하기 시작했습니다. 이유는 정리를 하면서 이해가 되지 않는 부분까지 명확히 짚고 넘어가게 되는 습관을 기르는 것과 함께 블로그를 통해 개발에 대한 관심을 어필할 수 있는 도구로 사용하기 위해서였습니다. 이후 책을 통해 학습한 것을 토대로 포트폴리오를 준비하며 구직활동도 병행하기 시작했는데 이전과 달랐던 점은 제가 깃을 사용한다는 점과 블로그를 통해 어떤 기술과 어떤 것들을 경험했는지에 대한 어필할 수 있는 것이 가장 큰 차이였습니다.\n다시 도전한 구직활동은 실패하고 싶지 않았지만 실제로 초반 결과는 크게 다르지 않았습니다. 하지만 지속적인 구직활동 끝에 후반쯤엔 운이 좋게 제 수준보다 높거나 자사 서비스를 가진 스타트업 회사들에게 서류 합격의 연락을 받을 수 있었고 지원한 수에 비례하여 적지만 다양한 회사들의 면접을 볼 수 있었습니다.\n 개인적으로 구직을 하면서 느낀점은 딱 한줄 요약으로 가능했습니다.\n내가 갈 수 있는 좋은 회사가 없는게 아니라 내가 매력적이지 않은 것이 아닐까?\n 서류 합격을 통해 면접을 준비하며 제가 가장 중요하게 생각했던 부분은 성장이었습니다. 개발팀에 대한 정보, 기술 스택, 업무 등을 가장 중요하게 생각했었고 운이 정말 좋게도 배려와 존중 속에 좋은 방향으로 성장할 수 있는 환경을 갖추고 자사 서비스를 운영하고 있는 작은 스타트업에 입사할 수 있었습니다. 비록 늘 학습해왔던 언어와는 다른 언어를 사용했지만 주변 개발자분들을 통해 학습할 시절부터 언어는 도구라 생각하는 편이 낫다 는 말을 많이 들어 흔쾌히 거부감 없이 합류할 수 있었습니다. 그렇게 개발자가 되고자 독학을 시작으로 1년 4개월 만에 원하는 회사에 입사하여 개발자로써 업무를 시작하게 되었습니다.\n신입 개발자 평소 유튜브를 즐겨보는 편은 아니지만 유독 챙겨 보는 것 채널은 백기선님의 채널과 그 외 개발 관련 채널들입니다. 백기선님의 영상을 통해 공부를 하기도 했지만 그 외 빠짐없이 보는 것 중 하나는 개발자 고민 콘텐츠 영상들입니다. 개발자 고민 영상은 꿀 팁이 많은데 그 중 신입 개발자는 어떤 업무를 해야 하는지 대한 내용이 저에게 가장 큰 도움이 되었습니다. 해당 영상의 결론은 신입 개발자는 질문을 해야 하며 이를 통해 자신이 속한 그룹에 빠르게 적응하고 업무를 익혀야 한다 는 내용이었습니다. 알고 나면 \u0026ldquo;맞아\u0026quot;라고 생각하지만 실질적으로 업무를 하면서 낯설고 처음이라 잘 떠오르지 않는 부분이기 때문에 출근을 시작하면서 늘 머릿속에 담아놓고 업무를 진행했으며 질문에 대한 것은 최대한 고민하고 찾아본 후 답변해주시는 팀원들을 배려하고자 이해하기 쉽게 질문을 정리하는 법 또한 조금씩 배워 나가고 있습니다.\n스타트업 스타트업은 많은 것들을 시도해볼 수 있으며 자유로운 분위기 속에 업무를 진행하는 것이 가장 큰 장점이라고 생각합니다. 말만 들었지 실제 회의에 참석하여 다양한 의견과 피드백을 통해 업무 진행 후 나온 결과물을 볼 때 정말 뿌듯하고 기분 좋은 경험이기에 저에겐 큰 매력으로 다가왔던 것 같습니다.\n또한 제가 속한 회사는 주기적으로 소소하게 코드 리뷰를 진행하고 개발자들끼리 관심 있는 기술에 대해 서로 발표하는 활동을 하는데 상상 이상으로 많은 도움이 되고 있어 더욱 업무 적응이 수월했던 것 같습니다. 얼마 전에는 업무에 사용하는 docker에 대해 간단하지만 ppt를 발표하기도 했고 직접적으로 많이 접할 수는 없지만 간접적으로 aws를 경험할 수 있는 환경은 정말 좋은 기회라 생각됩니다. 다만 지속적으로 공부하고 학습해왔던 java를 업무에 사용하지 않고 php와 node.js를 사용하는 점은 아쉽지만 현재 속한 상황에 최선을 다해야 한다고 생각하고 경력이 쌓였을 때보다 신입 때 다양한 언어를 경험해보는게 더 큰 장점이라 생각하기 때문에 지금은 매우 만족스럽게 적응해나가고 있습니다.\n출퇴근 출퇴근 시간이 왕복 3시간 정도 소요되기 때문에 이 시간이 너무 아까웠습니다. 출퇴근 시간으로 개인 시간을 할애하기 때문에 체력적으로 문제가 되거나 스트레스로 다가올 수 있었지만 없으면 내가 시간을 잘 활용하자라는 생각으로 입사 후 2달 동안 틈틈이 졸린 눈을 비벼가며 서서 가는 지하철에서 백기선님의 스프링 입문, 스프링 프레임워크 핵심 기술, 스프링 부트 개념과 활용 등 강좌만 3개를 수강했습니다. 피곤함과 수면 부족, 컨디션 난조 등을 핑계로 평일 5일 내내 출퇴근시간을 온전히 100% 활용하지 못했지만 최대한 지치지 않고 일주일에 1강이라도 공부하자라는 패턴을 유지하면서 잘 마무리할 수 있었습니다. 실질적으로 업무에 사용하는 언어는 아니지만 가장 오랜 시간 투자했던 자바와 스프링이기에 우선적으로 학습하고 싶어서 부트 개념까지만 수강하고 자바와 스프링 쪽은 당분간 잠시 쉴까 생각중입니다.\n현재는 업무에서 사용할 node.js를 얼마전 학습을 시작했는데 새로운 것을 학습하는 것은 언제나 즐거운 것 같습니다.\n마치며 이제 겨우 2개월밖에 되지 않은 신입 개발자라 부족함이 많아 매일 많은 것들을 배우고 경험하고 있으며 경험하는 모든 것들을 소중하고 감사하게 여기며 보내고 있습니다. 실제로 배움엔 돈을 아끼지 말자라는 생각을 가지고 있어 취업 준비하면서 구입한 책과 유료 강좌만 합해도 약 60만 원에 가까운 돈을 투자했던 것 같습니다. 최근엔 저와 비슷한 상황에 개발자에 관해서 관심이 있는 분에게 도움 될만한 얘기를 해드리는 기회가 있었는데 늘 받기만 했던 입장에서 작지만 줄 수 있는 입장이 되니 기분이 오묘했습니다. 아직은 초보개발자라 큰 도움이 되지 못하지만 나중에 좋은 방향으로 잘 성장해서 제가 받은 만큼 누군가에게 베풀고 싶은 마음을 가지는 계기가 되었던 좋은 경험이었습니다.\n2019년은 천국과 지옥을 오가며 나름 성공적으로 보냈다고 생각합니다. 1년 동안 개발자가 되기 위해 노력하며 가장 중요하다고 느꼈던 것은 습관이었는데 평소 아무런 계획을 세우지 않으면 무념무상으로 보내는 성향을 알기에 제 자신에게 늘 가혹하게 룰을 정해서 생활했던 기억이 납니다. 스트레스를 많이 받을 수 있지만 심적으로 혹은 결과적으로 저에겐 좋은 습관을 가질 수 있는 장치로 작용하게 되었고 덕분에 더 큰 목표를 바라보고 계획할 수 있는 자신감을 가질 수 있게 되었습니다.\n남은 3개월의 2019년은 다가올 2020년에 해야 할 일과 목표를 위해 조금 정리하는 시간을 가질 예정이며 개발자로써 1년 뒤 회고록을 쓸 성장한 제 모습을 상상하며 이만 글을 마치겠습니다. 이 글을 보시는 모든 예비 신입 개발자분들 응원합니다 !! : )\n","description":"","id":27,"section":"posts","tags":["개발자회고","비전공개발자"],"title":"고졸 비전공 개발자의 스타트업 도전기","uri":"https://live-jh.github.io/posts/think/newbie-developer-review/"},{"content":" 2020년 상반기를 돌아보며 간략히 정리하는 글입니다.\n 1~3월 그렇게 원하던 개발자로써 커리어 전환과 함께 취업 후 회사 생활도 잘 적응하며 보냈던\n2019년을 마무리하고 미국을 다녀오며 2020년 계획을 세웠다.\n계획이라 하지만 크게 변한 것들은 없었다.\n기본에 충실하자는 생각은 변함이 없었고 계획에 따른 습관에 초점을 맞췄다.\n1월부터 출퇴근 대중교통 시간을 활용해 영어 단어를 외우기 시작했다.\n하루 3개씩, 이게 힘들다면 단 1개라도 꾸준히 하자라는 목표로 시작했고\n큰 무리 없이 약 한 달 반정도 꾸준히 유지했다.\n하지만 겨우 습관이 들었다 싶었을 때쯤 개인 사정에 의해 집중도가 흐려져 잠시 중단한 상태다.\n그리고 작년 말 미국 LA 여행을 가기 전 IT전문 컨설팅 회사 이사님에게 메일을 받았다.\n알고 보니 체대생개발자 분의 블로그에 등장하신 이사님이셨고\n메일은 \u0026quot;직접 만나보고 싶다\u0026quot;라는 내용이었다.\n객관적으로 나는 부족한 부분이 많았지만 오히려 이러한 부분을 인정하고 더 보완하고 싶은\n욕심에 나는 주저하지 않고 연락을 드렸고\n미국 일정 이후 약속을 잡고 강남 근처에서 이사님을 직접 만나 뵙게 되었다.\n현재는 헤드헌터 일을 하고 계시지만 실제 개발일을 오랜 시간 하셨던 분이라 그런지\n말씀해주신 내용이 모두 주옥같았다.\n짧은 시간이었지만 뼈와 살이 되는 말들을 많이 해주셔서 머릿속에 기억해놓고 집에 가는 길에\n입꼬리가 귀에 걸린 채로 메모장에 메모를 남겼던 기억이 아직도 아른하다.\n지금까지 살면서 누군가의 인정 과 칭찬 은 나와 가깝지 않다 생각했지만\n이날만큼은 그동안 개발자를 위해 해왔던 모든 의미가 명확해지는 순간이었다.\n그외 1월은 예전부터 하고 싶었던 글또 모임도 신청했지만\n코로나와 함께 개인 사정으로 인해 포기하고 다음 기수에 다시 재신청 하기로 마음먹었다.\n2월부터는 본격적으로 개인 사정이라 표현했던 결혼준비를 시작한 시기다.\n2월부터 본격적이 된 사건이 하나 더 있는데 바로 코로나19 이다.\n나뿐만 아니라 모든 국민 전체가 힘든 시기의 시작으로\n밖에 나가지 못하는 점을 틈타 전문학사에 필요한 컴활 2급 자격증을 따기 위해\n컴활 2급 필기시험을 준비했다. 약 2주간 기출문제만 풀었고 오답 노트를 정리해\n출퇴근마다 보기 시작했다. 그 결과 예상한 점수보다 여유롭게 합격했지만 이후\n실기시험은 코로나로 인해 연기가 되었고 결혼 준비와 함께 자연스레 잠정 중단 상태가 되버렸다.\n3월은 회사의 사수분과 주말 스터디 형식으로 토이프로젝트를 진행했다.\n토이프로젝트는 기획부터 DB 설계, 프로젝트 세팅, 디자인 구성까지 일수로 약 3일 정도\n주말 시간을 사용해 진행했지만 3월 말부터는 본격적인 결혼준비 때문에 중단한 상태이다.\n 내 토이프로젝트는 결혼 후 무적권 끝낸다!!!!!\n 4~6월 인생 최고의 이벤트인 결혼을 준비했던 시간이었다.\n나와 평생을 약속한 신부는 나와 성향이 비슷해 야외에서 밤에 하는 결혼을 하고 싶어 했고\n또한 커스터마이징이 가능한 예식을 원했다.\n그로 인해 웨딩을 컨설팅해주는 업체를 찾아야 했고 거의 셀프웨딩 형식으로 준비하게 되었다.\n그로 인해 남들보다는 상대적으로 조금 더 신경 쓸 부분들이 많아 부담스러웠던 적도 있지만\n지난 시간을 돌이켜보면 우리가 한 선택의 의미를 곱씹으며 즐겁게 준비했던 것 같다.\n결혼을 약 한 달 반 남긴 시점에서 드는 생각이지만 결혼은 정말 많은 것을 경험할 수 있는 것 같다.\n너무나 많은 경험을 하면서 매 순간 힘들다는 생각보다\n혼자가 아닌 우리가 함께 해나가서 그런지 모든 것들이 뜻깊고 소중했던 기억이 더 많았다.\n그 중 야외 촬영이 가장 기억에 많이 남는데 이유는 뭐라 설명하기 어렵다.\n말로 표현할 수 없는 그런 느낌이라 이유를 적을 수 없는게 나도 아쉽다. ㅠ\n그외 이슈 기술스택 상반기 동안 나는 회사에서 여러 경험을 할 수 있었다.\n프로젝트별로 React\u0026amp;Nodejs, Django\u0026amp;Python을 사용하게 되었는데\n아무래도 처음이다 보니 러닝 커브로 인해 속도가 매우 더디고 내가 하는 것들이\n맞는지에 대한 의문을 가진 채로 코드를 작성했었다.\n욕심이 많았던 것인지 해도 안 되는 부분 때문에 이때 스트레스가 거의 극에 달했지만\n다행히 같이 프로젝트를 진행하는 동료들 덕분에 큰 문제 없이 잘 마무리할 수 있었다.\n1월쯤 React를 사용한 프로젝트를 현재 기능을 더하기 위해 다시 진행하고 있는데\nReact를 계속 사용하지 않았음에도 불구하고 내가 작성한 코드가 좋지 않다는 게 눈에 보여 신기했다.\n현재는 조금 더 효율적인 코드를 고려해서 작성하려 노력하고 있고\n상태관리를 위해 mobx 를 사용하고 있다.\n그리고 3월부터 약 두 달 간 Python과 Django를 사용해 애드캠퍼스 웹 리뉴얼 작업을 진행했다.\n나는 대학 쪽을 맡아서 작업을 진행했었는데 개인적으로 이때 가장 많이 성장했던 것 같다.\n프론트엔드 스크립트 기능부터 시작해 작지만 내가 맡은 기능의 일부 API를 구현하면서\n백엔드, 프론트엔드 가리지 않고 개발했다.\n초반엔 프로젝트 경험도 적고 Django와 Python에 익숙하지 않았기에 좀처럼 속도가 나지 않았다.\n실제로 출근해서 코드를 썼다가 지웠다가만 반복하다가 퇴근하던 날도 있었는데\n조금씩 누적이 되다 보니 마음이 너무 불안했었다.\n다행히 좋은 팀원을 둔 덕에 기한에 맞춰 프로젝트를 끝낼 수 있었고 그동안 개발 과정을 떠올리니\n많은 성장을 했다 라는 생각이 들었다.\n여기서 내가 말한 성장이라는 건 엄청난 것을 잘하는 것도 빠른 속도로 정확하게 개발하는 것도 아니다.\n내가 성장했다고 느꼈던 부분은 시야가 넓어진 점이다.\n나는 고등학교때 입시미술을 잠깐 1년정도 했는데 그림에 소질도 없고 디자인도 잘하던 타입이 아니었다.\n학원에서는 2~3일에 한 작품씩 평가를 받았었는데 나는 매번 미완성의 연속이었다.\n미완성의 이유는 간단했다. 그림은 전체를 보며, 부족한 부분을 채워나가면서 완성을 해야 하는데\n나는 매번 하나에 밀도 있게 묘사를 하다 보니 결국 배경을 보지 못하는 등 문제가 발생했다.\n개발도 마찬가지라고 생각한다. 한 서비스를 개발한다는 것은 예외처리 또는 버그와의 싸움인데\n시야가 넓을수록 필요한 기능을 고려해서 일을 두 번 하는 일이 줄어든다는 사실이 매우 흡사하다.\n물론 다양한 요소가 있겠지만 내가 느꼈던 부분에서 시야는 매우 일부분이라 생각한다.\n하지만 이 또한 나에겐 매우 값진 경험이었고 앞으로도 나를 조금 더 나은 개발자로 나아갈 수 있도록\n만드는 원동력이라고 생각한다.\n 마지막으로 부족한 나를 두고 고생한 팀원들에게 다시 한번 감사의 말을 전하고 싶다 :)\n 하반기? 키워드로 정리하자면 다음과 같다.\n 결혼 토이프로젝트 운동 \u0026amp; 영어 독서 학점은행제 진행 회사 업무  첫번째는 결혼이다. 새로운 가족과 함께 삶을 그려나가는 인생의 전환점이라 생각한다.\n코로나때문에 순탄치 못했지만 최대한 주변 분들에게 피해를 끼치지 않는 선에서\n잘 마무리되길 바라며 준비하고 있다.\n두번째로 운동 및 영어는 무조건 습관으로 만들고자 한다.\n올해가 지나도 매년 꾸준히 내 생활에 녹아들도록 수단과 방법을 가리지 않을 것이며\n추가하자면 독서까지도 생각하고 있다.\n구체적인 계획은 결혼이 끝나고 세울 예정이며 절대 부담스러운 목표설정을 하지 않으려 한다.\n지치면 쉽게 손을 놓아 버리는 것을 잘 알기에 나의 패턴을 잘 고려할 생각이다.\n세 번째는 회사 업무와 토이프로젝트를 진행하며 개발자로써의 역량을 더욱 키워나갈 것이다.\n회사에서 사용하는 기술 스택을 기반으로 업무 효율성을 높이면서\n개인적으로는 토이프로젝트를 진행할 예정이다.\n이와 동시에 알고리즘도 필수는 아니지만, 선택적으로 조금씩 두드릴 계획을 가지고 있다.\n마지막으로는 전문학사를 위한 마무리 작업을 할 예정이다.\n하반기를 포함한 내년 상반기까지 전문학사를 마칠 계획이다.\n나열한 것들을 보면 신혼인 시기에 조금은 힘들겠지만\n그만큼 내가 더 노력하고 시간 관리만 잘한다면 충분히 가능하다고 생각한다.\n work = home = play = sleep 😅😂🤣\n 마치며 상반기에는 많은 것들을 하지 못했다. 반대로 생각해보면 많은 것을 얻었다.\n개인적으로 해야 할 것들을 못했지만, 더 값진 것을 선택해 후회 없는 시간을 보냈다고 장담한다.\n시간이 흐른 뒤에 어떤 것을 더 후회할까라고 생각하면 전혀 단 1%도 후회하지 않는다.\n오히려 갈증이 쌓이다 보니 다음에 다시 내가 세웠던 계획들을 재개했을 때\n더욱 즐겁고 행복하게 할 수 있을 것 같은 느낌이 든다.\n마지막으로 100% 예전으로 돌아갈 수 없겠지만 코로나19가 하루라도 빨리 잠잠해져서 이전 생활을\n되찾고 조금이라도 지금보다 행복했으면 좋겠다. 😄\n","description":"","id":28,"section":"posts","tags":["2020회고","개발자회고"],"title":"2020년 상반기, 비전공 개발자로 1년 회고","uri":"https://live-jh.github.io/posts/think/2020-half-first-retrospective/"},{"content":" 개발자가 된 이후 한해를 정리하며 반성하고 앞으로의 계획을 세우기 위한 회고록으로 일기처럼 간략히 정리한 포스팅입니다.\n  퇴사 (18.11 ~ 19.01) 음악 교육업에 종사하다 개발자가 되기 위해 약 1년간 준비 후 입사한 첫 회사를 수습 기간 도중 퇴사하였다. 내가 추구하는 가치관과 회사는 조금 다른 차이를 보였기 때문이다. 나는 레거시한 프로젝트를 반복하기보다는 최근 트렌드에 맞춰 다양한 경험할 수 있고 자사서비스를 지속해서 고도화시킬 수 있는 업무를 원했다.\n회사에 다니는 동안 지인 또는 주변 개발자분들과 만나 여러 의견을 들으며 나의 생각을 종합해봤다. 나는 내가 판단한 방향성을 택하기로 정했고 결정에 대한 실행은 크게 두 가지가 있었다.\n첫 번째는 내가 당장 속한 그룹에서 이직 준비를 진행하는 방법과 두 번째 내가 많은 역할을 부여받지 않았지만 조금이라도 회사의 비용을 최소화하기 위해 최대한 빨리 의사를 내비치고 퇴사 후 준비하는 방법이었다. 고민 끝에 나는 두 번째 방법을 택하기로 했고 회사와 이야기를 나눈 끝에 기분 좋은 마무리를 지을 수 있었다. ( p.s 짧은 기간이었지만 감사했습니다 !! )\n재취업준비 (19.02 ~ 19.06) 몰라서 겁이 없었던 것 같다. 무엇이든 다 할 수 있을거라 믿었고 나 자신을 믿을 수 밖에 없는 상황이었다. 학점은행제와 독학사 그리고 취업준비까지 3개를 동시에 시작 했고 2월 한 달간은 1년에 한 번밖에 없는 독학사 시험에 집중했다.\n독학사 시험 이후 학점은행제와 취업준비 2개만 병행하였는데 학점은행제는 수업만 듣고 시험 및 과제만 잘 제출하면 돼서 비교적 부담이 적었지만 취업준비는 녹록지 않았다. 누구나 다 똑같은 이력서겠다 싶어 나만의 차별성과 어필할 수 있는 수단을 만들고자 고민을 하기 시작했다. 꾸준함과 분야에 대한 욕심을 보여줄 수 있는 것은 크게 블로그와 토이프로젝트가 있었다.\n나는 지속 과 꾸준함 을 선택했다.\n 지속과 꾸준함을 선택했다 하지만\n실제로는 그렇게 만족스러운 지속과 꾸준함은 아니었던 것 같다.. ㅠ\n 깃헙 블로그를 생성하여 공부한 내용을 몇 시간씩 투자하여 겨우 정리하여 올렸고 나와 같은 비슷한 사람들의 블로그를 보게 되었을 땐 직접 연락하여 만나 이런저런 조언도 듣곤 했었다. 그 결과 4개월 뒤 나는 운이 좋게 자사서비스 회사에 재취업을 할 수 있게 되었다.\n스타트업 (19.07 ~ 19.12) 다양한 경험을 할 수 있다는 장점이 매우 좋은 것 같다. 다양한 경험이라는 게 성향이 맞지 않는다면 그게 엄청난 단점으로 다가올 수 있다고 생각한다. 평소 경험하는 것에 거부감이 없어 오히려 스타트업에서 다양한 일을 경험하는게 가끔 즐거울 때도 있다. 스타트업을 다니면서 좋은 것들은 일하면서 코드리뷰도 하고 간략한 기술세미나 등을 진행한다는 점인데 좋은 개발문화 활동들을 통해 더 나를 성장하게 만드는 발판을 마련하는 것 같아 매우 만족스럽다. 다만 출퇴근 거리가 너무 멀어 조금 힘든 점이 아쉽다. 출퇴근 시간이 아까워 핸드폰으로 동영상 강좌를 보며 공부하는 습관이 생긴 것을 보면 아주 조금은 적응한 것처럼 느껴지기도 한다.\n약 6개월간 해온 업무는 베어유라는 청년층을 위한 커리어 동영상 강의 플랫폼 CMS 구축 작업이었다. CMS내에 내가 담당한 부분은 간단한 공지사항부터 시작해서 강의 등록시 태그 작업, 강사 정산, 매출 대시보드 및 리스트, 회원 대시보드 및 리스트 등이었다. 이 중 가장 기억에 남는건 매출 정산에 대한 기능이다. 정산 기능은 구현 중간에 여러 기능이 추가가 되면서 기획이 변경되는 일이 종종 발생했다. 한번은 세금계산에 필요한 속성이 추가되었고 간단한 작업이 될줄 알았지만 위변조 검사시 계산이 클라이언트쪽과 서버쪽이 다른 상황이 발생했다.\n 살려주십쇼..\n 한참을 삽질을 하며 찾아보니 문제는 내 코드였다. 지저분해서 디버깅도 힘들고 가독성도 낮아 나만 보기 좋은 코드가 아닌 나조차도 보기 힘든 코드였다. 코드를 간결하게 작성하라는 피드백을 받고 비교할 때 공통적으로 필요한 속성을 모아 함수로 만들고 필요없는 변수 선언은 죄다 지우기 시작했다.\n작업이 끝난 이후 다시 한번 코드 리뷰를 받을 수 있었다.\n 이 부분은 지금보다 더 깔끔하게 하기 힘들 것 같아요\n 모든 코드가 다 완벽하지 않았지만 그 어떤 것보다 소중한 성취감을 느낄 수 있었던 개발팀장님의 한마디였다.\n또한 도커를 활용해 빌드환경을 구성하기에 도커에 대해 학습하고 PPT로 사내 개발팀 회의때 발표를 한 것도 매우 뜻 깊은 경험이었다.\n건강 건강은 정말 중요하다. 2019년 연말은 가족의 건강으로 인해 모든 계획이 멈출 수밖에 없었다. 할머니의 건강악화로 인해 가족들 모두 할머니에게 집중할 수 밖에 없었다. 어릴 적 할머니 밑에서 자라서 그런지 할머니에 대한 애정이 나는 남다른 편이라 계획했던 일을 모두 멈추고 할머니에게 모든 일정을 맞췄다. 이번을 계기로 가장 크게 깨달은 것은 가족과 건강이 삶에 있어 얼마나 큰 비중을 차지하는지에 대해 소중함을 느낀 것이다. 돈, 권력, 지위, 명예, 경제력 살아가는 데 있어 매우 중요한 요소들이지만 나에겐 이보다 더 큰 삶의 가치가 있다는 것을 깨닫게 해준 순간이었다.\n 젊다고 방심하면 훅간다.\n2020년 운동은 필수!\n 학점은행제 (19.02 ~ 19.12) 학점은행제는 취업하기 전 기초가 부족한 부분을 채우기 위한 공부 겸 전문학사를 위해 시작했다. 온라인 강의라 부담이 없을 줄 알았으나 생각보다 시간을 잡아먹는 경우가 많았다. 그냥 켜놓고 족보를 통해 시험을 보는 사례가 많다고 들었지만 나는 그렇게 하기 싫어서 시험 보기 전 3주 전부터는 퇴근 후 매일 공부하며 시험준비를 했었다. 결과적으로 잘 풀린 과목도 있었지만 3주 전 공부가 먹히지 않는 과목도 있었다. 내년은 인생의 가장 큰 이벤트 (결혼 = New Family!!)가 있어서 확답할 순 없지만 최대한 네트워크, 자료구조, 알고리즘 공부와 함께 남은 전문학사 과정도 마무리할 수 있도록 노력할 예정이다.\n 기말고사 성적.png\n어릴때 공부좀 할껄 ㅠㅜㅜㅜㅜㅜㅜ\n 미흡했던점 (운동/독서/영어) 취업 이후 9월쯤부터 업무가 앉아있는 시간이 많아 운동이 필요하다고 느꼈다. 나는 헬스장 운영에 큰 후원을 하고 나가지 않는 실수를 반복하지 않기 위해 내 자신에게 작은 미션을 주었다. 집에서 아주 적은 양의 운동을 부여하고 그것을 2달정도 꾸준히 이어나가면 헬스장을 등록하기로 마음 먹었다.\n중간에 마라톤 대회를 위해 준비한 연습을 포함해 약 6주정도 지속했으나 결과는 좋지 않았고 (그럼 그렇지..) 때마침 할머니의 건강악화로 인해 운동과 비슷한 시기에 시작한 영어공부까지도 멈추게 되었다. 멘탈이 나가서인지 모르겠지만 약 2달 정도를 거의 쉬고 있는 상태다. 확실히 조금이라도 운동할 때는 나아지는 게 느껴졌는데 안하다 보니 금방 체력이 쓰레기로 되돌아오는 것이 느껴진다.\n 내년쯤엔 내 배에도 식스팩이 생길까?\n 독서 또한 이런저런 핑계로 개발 관련 책 3권밖에 읽지 못했다. 매우 반성해야 할 부분이며 매년 중요성을 알면서도 잘 실천하지 못하는 것에 더 오기가 생기기 시작했다. 장난스레 적었지만 속으로는 이를 갈고 있으며 내년에는 기필코 달라진 결과를 마주하며 기분 좋게 회고록을 작성할 수 있었으면 좋겠다.\nNext Year.. 내년엔 조금 더 활동적이고 체력도 길러 활동 범위를 넓혀 나갈 계획이다. 다양한 사람들을 만나 긍정적인 영향을 받아 조금 더 나를 성장시키는 계기로 만들 것이다. 또 책과 영어 그리고 운동과 조금 더 친해지는 것이 목표다. 내가 취준생 시절부터 지금까지 꾸준히 반복적으로 보는 강연 하나가 있다. 체력 하나만 달라져도 인생의 많은 것들이 변합니다 라는 세바시 강연이다.\n운동할 때 나는 이 영상을 지속적으로 보는데 나에게는 그 어떤 음악보다 훨씬 운동 자극 효과가 좋았다. 내년엔 꼭 강연의 내용을 누구보다 200% 이상 공감할 수 있도록 운동을 습관화할 계획이다. 2020년은 운동을 통해 얻은 체력을 바탕으로 내가 하고자 하는 영어 공부나 독서 및 개인 프로젝트 등을 시간을 효율적으로 사용하여 조금 더 성장할 수 있는 한 해가 될 수 있길 소망한다.\n","description":"","id":29,"section":"posts","tags":["2019회고","개발자회고"],"title":"고졸 비전공 개발자의 2019년 회고","uri":"https://live-jh.github.io/posts/think/2019-retrospective/"}]